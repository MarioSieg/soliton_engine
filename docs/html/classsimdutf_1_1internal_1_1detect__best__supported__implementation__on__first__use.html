<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lunam Engine: simdutf::internal::detect_best_supported_implementation_on_first_use Class Reference</title>
<link rel="icon" href="logo_small.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Lunam Engine
   </div>
   <div id="projectbrief">Realtime Simulation Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsimdutf_1_1internal_1_1detect__best__supported__implementation__on__first__use.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classsimdutf_1_1internal_1_1detect__best__supported__implementation__on__first__use-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simdutf::internal::detect_best_supported_implementation_on_first_use Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for simdutf::internal::detect_best_supported_implementation_on_first_use:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsimdutf_1_1internal_1_1detect__best__supported__implementation__on__first__use.png" usemap="#simdutf::internal::detect_5Fbest_5Fsupported_5Fimplementation_5Fon_5Ffirst_5Fuse_map" alt=""/>
  <map id="simdutf::internal::detect_5Fbest_5Fsupported_5Fimplementation_5Fon_5Ffirst_5Fuse_map" name="simdutf::internal::detect_5Fbest_5Fsupported_5Fimplementation_5Fon_5Ffirst_5Fuse_map">
<area href="classsimdutf_1_1implementation.html" alt="simdutf::implementation" shape="rect" coords="0,0,397,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88e4337bb6248cbf1c470949cba19968" id="r_a88e4337bb6248cbf1c470949cba19968"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88e4337bb6248cbf1c470949cba19968">name</a> () const noexcept final</td></tr>
<tr class="separator:a88e4337bb6248cbf1c470949cba19968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac391010f27fed7f369fec1da303b6df9" id="r_ac391010f27fed7f369fec1da303b6df9"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac391010f27fed7f369fec1da303b6df9">description</a> () const noexcept final</td></tr>
<tr class="separator:ac391010f27fed7f369fec1da303b6df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada52e4977bb9fb646b4d8fa47fb915bc" id="r_ada52e4977bb9fb646b4d8fa47fb915bc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada52e4977bb9fb646b4d8fa47fb915bc">required_instruction_sets</a> () const noexcept final</td></tr>
<tr class="separator:ada52e4977bb9fb646b4d8fa47fb915bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc43e4df43d667395a1e7237093d5ef2" id="r_adc43e4df43d667395a1e7237093d5ef2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc43e4df43d667395a1e7237093d5ef2">detect_encodings</a> (const char *input, size_t length) const noexcept override</td></tr>
<tr class="separator:adc43e4df43d667395a1e7237093d5ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46169a17b9077b17ca2b5ae2133c3c56" id="r_a46169a17b9077b17ca2b5ae2133c3c56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46169a17b9077b17ca2b5ae2133c3c56">validate_utf8</a> (const char *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:a46169a17b9077b17ca2b5ae2133c3c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f3886a54b3373b1021e2110234a3bf" id="r_a36f3886a54b3373b1021e2110234a3bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36f3886a54b3373b1021e2110234a3bf">validate_utf8_with_errors</a> (const char *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:a36f3886a54b3373b1021e2110234a3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5a644cc8682c969426b924578d89e5" id="r_a3f5a644cc8682c969426b924578d89e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f5a644cc8682c969426b924578d89e5">validate_ascii</a> (const char *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:a3f5a644cc8682c969426b924578d89e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7af57e80f8de7a3edcaa20254bb496a" id="r_aa7af57e80f8de7a3edcaa20254bb496a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7af57e80f8de7a3edcaa20254bb496a">validate_ascii_with_errors</a> (const char *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:aa7af57e80f8de7a3edcaa20254bb496a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14843f8f297ebc612066b307d7aeeb70" id="r_a14843f8f297ebc612066b307d7aeeb70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14843f8f297ebc612066b307d7aeeb70">validate_utf16le</a> (const char16_t *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:a14843f8f297ebc612066b307d7aeeb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a9696d74e33f200c7e5e3f2d7bc6b8" id="r_aa1a9696d74e33f200c7e5e3f2d7bc6b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1a9696d74e33f200c7e5e3f2d7bc6b8">validate_utf16be</a> (const char16_t *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:aa1a9696d74e33f200c7e5e3f2d7bc6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a94f2962cd848e2c15956b60f7bcdea" id="r_a8a94f2962cd848e2c15956b60f7bcdea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a94f2962cd848e2c15956b60f7bcdea">validate_utf16le_with_errors</a> (const char16_t *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:a8a94f2962cd848e2c15956b60f7bcdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ff9db850ed25ca6a3a33fb8852bda1" id="r_a05ff9db850ed25ca6a3a33fb8852bda1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05ff9db850ed25ca6a3a33fb8852bda1">validate_utf16be_with_errors</a> (const char16_t *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:a05ff9db850ed25ca6a3a33fb8852bda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8bd6ba3cde34e40723f9b5930e2bad" id="r_a0c8bd6ba3cde34e40723f9b5930e2bad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c8bd6ba3cde34e40723f9b5930e2bad">validate_utf32</a> (const char32_t *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:a0c8bd6ba3cde34e40723f9b5930e2bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a55750b9a99ea25b7d98934753f777" id="r_a42a55750b9a99ea25b7d98934753f777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42a55750b9a99ea25b7d98934753f777">validate_utf32_with_errors</a> (const char32_t *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:a42a55750b9a99ea25b7d98934753f777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a256291fec86a378cca324280d44e6" id="r_a37a256291fec86a378cca324280d44e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37a256291fec86a378cca324280d44e6">convert_latin1_to_utf8</a> (const char *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:a37a256291fec86a378cca324280d44e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c90be09ea92641dfd759b72c098f948" id="r_a4c90be09ea92641dfd759b72c098f948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c90be09ea92641dfd759b72c098f948">convert_latin1_to_utf16le</a> (const char *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:a4c90be09ea92641dfd759b72c098f948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469fa08e37c2fdea426ec6721db9d17d" id="r_a469fa08e37c2fdea426ec6721db9d17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a469fa08e37c2fdea426ec6721db9d17d">convert_latin1_to_utf16be</a> (const char *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:a469fa08e37c2fdea426ec6721db9d17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00ef8929e212338cbee01dbe5dcba41" id="r_ad00ef8929e212338cbee01dbe5dcba41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad00ef8929e212338cbee01dbe5dcba41">convert_latin1_to_utf32</a> (const char *buf, size_t len, char32_t *latin1_output) const noexcept final override</td></tr>
<tr class="separator:ad00ef8929e212338cbee01dbe5dcba41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5f4d773e8a863c364c74338b216300" id="r_aca5f4d773e8a863c364c74338b216300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca5f4d773e8a863c364c74338b216300">convert_utf8_to_latin1</a> (const char *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:aca5f4d773e8a863c364c74338b216300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c19ed979e4a43f5450970cdaa04332" id="r_ac8c19ed979e4a43f5450970cdaa04332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8c19ed979e4a43f5450970cdaa04332">convert_utf8_to_latin1_with_errors</a> (const char *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:ac8c19ed979e4a43f5450970cdaa04332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335e4d43cd4e7601231e0c96b85f9f64" id="r_a335e4d43cd4e7601231e0c96b85f9f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a335e4d43cd4e7601231e0c96b85f9f64">convert_valid_utf8_to_latin1</a> (const char *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:a335e4d43cd4e7601231e0c96b85f9f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634081878fde335d096214412a340145" id="r_a634081878fde335d096214412a340145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a634081878fde335d096214412a340145">convert_utf8_to_utf16le</a> (const char *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:a634081878fde335d096214412a340145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a22a82092f1e449028ae73890bf140" id="r_a68a22a82092f1e449028ae73890bf140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68a22a82092f1e449028ae73890bf140">convert_utf8_to_utf16be</a> (const char *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:a68a22a82092f1e449028ae73890bf140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c2b3cac02ccd52bec3e05c53a77bf6" id="r_ac7c2b3cac02ccd52bec3e05c53a77bf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7c2b3cac02ccd52bec3e05c53a77bf6">convert_utf8_to_utf16le_with_errors</a> (const char *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:ac7c2b3cac02ccd52bec3e05c53a77bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f09d5277d40a7c3f853267854279908" id="r_a0f09d5277d40a7c3f853267854279908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f09d5277d40a7c3f853267854279908">convert_utf8_to_utf16be_with_errors</a> (const char *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:a0f09d5277d40a7c3f853267854279908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeda5e99a6b7eeeaae444c13b99d1d5" id="r_abeeda5e99a6b7eeeaae444c13b99d1d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeeda5e99a6b7eeeaae444c13b99d1d5">convert_valid_utf8_to_utf16le</a> (const char *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:abeeda5e99a6b7eeeaae444c13b99d1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ed4cd72a0d6f61163b7ead54222247" id="r_a23ed4cd72a0d6f61163b7ead54222247"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23ed4cd72a0d6f61163b7ead54222247">convert_valid_utf8_to_utf16be</a> (const char *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:a23ed4cd72a0d6f61163b7ead54222247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18801cca96d630b0657a26953775f3e6" id="r_a18801cca96d630b0657a26953775f3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18801cca96d630b0657a26953775f3e6">convert_utf8_to_utf32</a> (const char *buf, size_t len, char32_t *utf32_output) const noexcept final override</td></tr>
<tr class="separator:a18801cca96d630b0657a26953775f3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0bddef27f14274b402e1cb0c5653f3" id="r_a5b0bddef27f14274b402e1cb0c5653f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b0bddef27f14274b402e1cb0c5653f3">convert_utf8_to_utf32_with_errors</a> (const char *buf, size_t len, char32_t *utf32_output) const noexcept final override</td></tr>
<tr class="separator:a5b0bddef27f14274b402e1cb0c5653f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad35dd5a2909171aa932b8355c39b81b" id="r_aad35dd5a2909171aa932b8355c39b81b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad35dd5a2909171aa932b8355c39b81b">convert_valid_utf8_to_utf32</a> (const char *buf, size_t len, char32_t *utf32_output) const noexcept final override</td></tr>
<tr class="separator:aad35dd5a2909171aa932b8355c39b81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b856c2a8c7ae9ac022f9718436ba66" id="r_a45b856c2a8c7ae9ac022f9718436ba66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45b856c2a8c7ae9ac022f9718436ba66">convert_utf16le_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:a45b856c2a8c7ae9ac022f9718436ba66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24963a2bf68d895d73e9d285fd63e298" id="r_a24963a2bf68d895d73e9d285fd63e298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24963a2bf68d895d73e9d285fd63e298">convert_utf16be_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:a24963a2bf68d895d73e9d285fd63e298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddadc05af70ed6f56fa25c0491292ce" id="r_abddadc05af70ed6f56fa25c0491292ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abddadc05af70ed6f56fa25c0491292ce">convert_utf16le_to_latin1_with_errors</a> (const char16_t *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:abddadc05af70ed6f56fa25c0491292ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fa0b0063bf1610ba3cf72246bd97ff" id="r_a69fa0b0063bf1610ba3cf72246bd97ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69fa0b0063bf1610ba3cf72246bd97ff">convert_utf16be_to_latin1_with_errors</a> (const char16_t *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:a69fa0b0063bf1610ba3cf72246bd97ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75da7cc61fdb5d736b05d23fff356f2b" id="r_a75da7cc61fdb5d736b05d23fff356f2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75da7cc61fdb5d736b05d23fff356f2b">convert_valid_utf16le_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:a75da7cc61fdb5d736b05d23fff356f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc0acabc47a2307ddf7c889f23c7e2d" id="r_abdc0acabc47a2307ddf7c889f23c7e2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdc0acabc47a2307ddf7c889f23c7e2d">convert_valid_utf16be_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:abdc0acabc47a2307ddf7c889f23c7e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce5ecaf602f39cd5321c5de6bf3439d" id="r_acce5ecaf602f39cd5321c5de6bf3439d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acce5ecaf602f39cd5321c5de6bf3439d">convert_utf16le_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:acce5ecaf602f39cd5321c5de6bf3439d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eed73d54da091fd0ec0908602724f1" id="r_ab5eed73d54da091fd0ec0908602724f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5eed73d54da091fd0ec0908602724f1">convert_utf16be_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:ab5eed73d54da091fd0ec0908602724f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fa33d08a81f6b5a7977f1b4d436a41" id="r_aa6fa33d08a81f6b5a7977f1b4d436a41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6fa33d08a81f6b5a7977f1b4d436a41">convert_utf16le_to_utf8_with_errors</a> (const char16_t *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:aa6fa33d08a81f6b5a7977f1b4d436a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14955618e114ef69cba4eaa00c028bf3" id="r_a14955618e114ef69cba4eaa00c028bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14955618e114ef69cba4eaa00c028bf3">convert_utf16be_to_utf8_with_errors</a> (const char16_t *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:a14955618e114ef69cba4eaa00c028bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9432ea0e2328c0c9f2aab784a4186430" id="r_a9432ea0e2328c0c9f2aab784a4186430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9432ea0e2328c0c9f2aab784a4186430">convert_valid_utf16le_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:a9432ea0e2328c0c9f2aab784a4186430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3811bfe7062a30586d5aab5d6ece8ba6" id="r_a3811bfe7062a30586d5aab5d6ece8ba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3811bfe7062a30586d5aab5d6ece8ba6">convert_valid_utf16be_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:a3811bfe7062a30586d5aab5d6ece8ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dc55a151b331491752212f83328467" id="r_a36dc55a151b331491752212f83328467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36dc55a151b331491752212f83328467">convert_utf32_to_latin1</a> (const char32_t *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:a36dc55a151b331491752212f83328467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3bea933438d4e0ad2c51a32e64a636" id="r_aac3bea933438d4e0ad2c51a32e64a636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac3bea933438d4e0ad2c51a32e64a636">convert_utf32_to_latin1_with_errors</a> (const char32_t *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:aac3bea933438d4e0ad2c51a32e64a636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22e574e388f8b4523f685e71ddf7d99" id="r_af22e574e388f8b4523f685e71ddf7d99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af22e574e388f8b4523f685e71ddf7d99">convert_valid_utf32_to_latin1</a> (const char32_t *buf, size_t len, char *latin1_output) const noexcept final override</td></tr>
<tr class="separator:af22e574e388f8b4523f685e71ddf7d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a823aa90e1a7d7f644b5ba7cb671297" id="r_a7a823aa90e1a7d7f644b5ba7cb671297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a823aa90e1a7d7f644b5ba7cb671297">convert_utf32_to_utf8</a> (const char32_t *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:a7a823aa90e1a7d7f644b5ba7cb671297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b091a5f54877c92e10b1dd5178907c" id="r_a45b091a5f54877c92e10b1dd5178907c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45b091a5f54877c92e10b1dd5178907c">convert_utf32_to_utf8_with_errors</a> (const char32_t *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:a45b091a5f54877c92e10b1dd5178907c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22e626921c1e78335fdc13ed3a28f6a" id="r_aa22e626921c1e78335fdc13ed3a28f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa22e626921c1e78335fdc13ed3a28f6a">convert_valid_utf32_to_utf8</a> (const char32_t *buf, size_t len, char *utf8_output) const noexcept final override</td></tr>
<tr class="separator:aa22e626921c1e78335fdc13ed3a28f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ae3cc379e513b93a6a8eed91f00412" id="r_a71ae3cc379e513b93a6a8eed91f00412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71ae3cc379e513b93a6a8eed91f00412">convert_utf32_to_utf16le</a> (const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:a71ae3cc379e513b93a6a8eed91f00412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fbb8adcdc91b67e528c90c54e88f36" id="r_ac5fbb8adcdc91b67e528c90c54e88f36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5fbb8adcdc91b67e528c90c54e88f36">convert_utf32_to_utf16be</a> (const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:ac5fbb8adcdc91b67e528c90c54e88f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7fb2084883c8d5ed27c8faf46d57e8" id="r_a7b7fb2084883c8d5ed27c8faf46d57e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b7fb2084883c8d5ed27c8faf46d57e8">convert_utf32_to_utf16le_with_errors</a> (const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:a7b7fb2084883c8d5ed27c8faf46d57e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a755aa8cc56b32fb0aa1b0e3079b79" id="r_ac3a755aa8cc56b32fb0aa1b0e3079b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3a755aa8cc56b32fb0aa1b0e3079b79">convert_utf32_to_utf16be_with_errors</a> (const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:ac3a755aa8cc56b32fb0aa1b0e3079b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9143c5ec5c9f912960a00d0fe39c8f5f" id="r_a9143c5ec5c9f912960a00d0fe39c8f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9143c5ec5c9f912960a00d0fe39c8f5f">convert_valid_utf32_to_utf16le</a> (const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:a9143c5ec5c9f912960a00d0fe39c8f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace6ca098d9f8e6f40fb9986c124d5cc" id="r_aace6ca098d9f8e6f40fb9986c124d5cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aace6ca098d9f8e6f40fb9986c124d5cc">convert_valid_utf32_to_utf16be</a> (const char32_t *buf, size_t len, char16_t *utf16_output) const noexcept final override</td></tr>
<tr class="separator:aace6ca098d9f8e6f40fb9986c124d5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ace21b2351a224ea07aaf7a8b31044" id="r_a78ace21b2351a224ea07aaf7a8b31044"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78ace21b2351a224ea07aaf7a8b31044">convert_utf16le_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept final override</td></tr>
<tr class="separator:a78ace21b2351a224ea07aaf7a8b31044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d237f9f8ffc6263e24208aeb65be3c3" id="r_a1d237f9f8ffc6263e24208aeb65be3c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d237f9f8ffc6263e24208aeb65be3c3">convert_utf16be_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept final override</td></tr>
<tr class="separator:a1d237f9f8ffc6263e24208aeb65be3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf31e9fb10899f000e153238f158cd53" id="r_aaf31e9fb10899f000e153238f158cd53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf31e9fb10899f000e153238f158cd53">convert_utf16le_to_utf32_with_errors</a> (const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept final override</td></tr>
<tr class="separator:aaf31e9fb10899f000e153238f158cd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bd3ee43d746068beb077459acb725f" id="r_a73bd3ee43d746068beb077459acb725f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73bd3ee43d746068beb077459acb725f">convert_utf16be_to_utf32_with_errors</a> (const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept final override</td></tr>
<tr class="separator:a73bd3ee43d746068beb077459acb725f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a246bf9162caf68f65674e9b4cd987" id="r_a64a246bf9162caf68f65674e9b4cd987"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64a246bf9162caf68f65674e9b4cd987">convert_valid_utf16le_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept final override</td></tr>
<tr class="separator:a64a246bf9162caf68f65674e9b4cd987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0a017ed6ae898e12ec8eda1c87ceb5" id="r_a6a0a017ed6ae898e12ec8eda1c87ceb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a0a017ed6ae898e12ec8eda1c87ceb5">convert_valid_utf16be_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_output) const noexcept final override</td></tr>
<tr class="separator:a6a0a017ed6ae898e12ec8eda1c87ceb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3bfb3e9a82cbd98d16b9a83d0e7a0c" id="r_a6a3bfb3e9a82cbd98d16b9a83d0e7a0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3bfb3e9a82cbd98d16b9a83d0e7a0c">change_endianness_utf16</a> (const char16_t *buf, size_t len, char16_t *output) const noexcept final override</td></tr>
<tr class="separator:a6a3bfb3e9a82cbd98d16b9a83d0e7a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81f4ec3b85658c43d86d920544a9792" id="r_ad81f4ec3b85658c43d86d920544a9792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad81f4ec3b85658c43d86d920544a9792">count_utf16le</a> (const char16_t *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:ad81f4ec3b85658c43d86d920544a9792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e112acca8b18bb40b64e8533b6e483" id="r_ae2e112acca8b18bb40b64e8533b6e483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e112acca8b18bb40b64e8533b6e483">count_utf16be</a> (const char16_t *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:ae2e112acca8b18bb40b64e8533b6e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32020409f7ecdee625f9c6db83f5828" id="r_ae32020409f7ecdee625f9c6db83f5828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae32020409f7ecdee625f9c6db83f5828">count_utf8</a> (const char *buf, size_t len) const noexcept final override</td></tr>
<tr class="separator:ae32020409f7ecdee625f9c6db83f5828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3debe4483b6170bba9ad6045ee74a95a" id="r_a3debe4483b6170bba9ad6045ee74a95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3debe4483b6170bba9ad6045ee74a95a">latin1_length_from_utf8</a> (const char *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:a3debe4483b6170bba9ad6045ee74a95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4faf763d24adebb4ec372444499a56" id="r_aaa4faf763d24adebb4ec372444499a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa4faf763d24adebb4ec372444499a56">latin1_length_from_utf16</a> (size_t len) const noexcept override</td></tr>
<tr class="separator:aaa4faf763d24adebb4ec372444499a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b17c8be393e435246252036f6c3ed0e" id="r_a2b17c8be393e435246252036f6c3ed0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b17c8be393e435246252036f6c3ed0e">latin1_length_from_utf32</a> (size_t len) const noexcept override</td></tr>
<tr class="separator:a2b17c8be393e435246252036f6c3ed0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5c8377089b339a40b2f87ab2bd25b5" id="r_a0b5c8377089b339a40b2f87ab2bd25b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b5c8377089b339a40b2f87ab2bd25b5">utf8_length_from_latin1</a> (const char *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:a0b5c8377089b339a40b2f87ab2bd25b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd0def796bd23d1b127472426832d6" id="r_af9fd0def796bd23d1b127472426832d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9fd0def796bd23d1b127472426832d6">utf8_length_from_utf16le</a> (const char16_t *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:af9fd0def796bd23d1b127472426832d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9a6b38142dc8ffdcbb7b97931d45ee" id="r_adc9a6b38142dc8ffdcbb7b97931d45ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc9a6b38142dc8ffdcbb7b97931d45ee">utf8_length_from_utf16be</a> (const char16_t *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:adc9a6b38142dc8ffdcbb7b97931d45ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa184a01c73ac096bbf83f29f4a4d8da9" id="r_aa184a01c73ac096bbf83f29f4a4d8da9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa184a01c73ac096bbf83f29f4a4d8da9">utf16_length_from_latin1</a> (size_t len) const noexcept override</td></tr>
<tr class="separator:aa184a01c73ac096bbf83f29f4a4d8da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85167a96d66ce919f41b322fbed167e" id="r_ab85167a96d66ce919f41b322fbed167e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab85167a96d66ce919f41b322fbed167e">utf32_length_from_latin1</a> (size_t len) const noexcept override</td></tr>
<tr class="separator:ab85167a96d66ce919f41b322fbed167e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725be9fee94eeae7697e9a0ec433f2d9" id="r_a725be9fee94eeae7697e9a0ec433f2d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a725be9fee94eeae7697e9a0ec433f2d9">utf32_length_from_utf16le</a> (const char16_t *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:a725be9fee94eeae7697e9a0ec433f2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5cbf67bbf9d5f03c303431f64c9cd6" id="r_a7d5cbf67bbf9d5f03c303431f64c9cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d5cbf67bbf9d5f03c303431f64c9cd6">utf32_length_from_utf16be</a> (const char16_t *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:a7d5cbf67bbf9d5f03c303431f64c9cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd70ceb346095a22c1873f9a9708916e" id="r_afd70ceb346095a22c1873f9a9708916e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd70ceb346095a22c1873f9a9708916e">utf16_length_from_utf8</a> (const char *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:afd70ceb346095a22c1873f9a9708916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796316128259e64fb520343283d83136" id="r_a796316128259e64fb520343283d83136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a796316128259e64fb520343283d83136">utf8_length_from_utf32</a> (const char32_t *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:a796316128259e64fb520343283d83136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f87ab088fbf0a0fa3fbf82b62068d0" id="r_a66f87ab088fbf0a0fa3fbf82b62068d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f87ab088fbf0a0fa3fbf82b62068d0">utf16_length_from_utf32</a> (const char32_t *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:a66f87ab088fbf0a0fa3fbf82b62068d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8155d51fc6d5ea1ab54288888474500" id="r_ab8155d51fc6d5ea1ab54288888474500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8155d51fc6d5ea1ab54288888474500">utf32_length_from_utf8</a> (const char *buf, size_t len) const noexcept override</td></tr>
<tr class="separator:ab8155d51fc6d5ea1ab54288888474500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9df59f306ae69bbada152b133d1c862" id="r_aa9df59f306ae69bbada152b133d1c862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a7a2290defcac825573ce84885fd832d2">simdutf_really_inline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9df59f306ae69bbada152b133d1c862">detect_best_supported_implementation_on_first_use</a> () noexcept</td></tr>
<tr class="separator:aa9df59f306ae69bbada152b133d1c862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsimdutf_1_1implementation"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsimdutf_1_1implementation')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsimdutf_1_1implementation.html">simdutf::implementation</a></td></tr>
<tr class="memitem:a6cd8f7d8787c76e690ed9c4151abb7a9 inherit pub_methods_classsimdutf_1_1implementation" id="r_a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6cd8f7d8787c76e690ed9c4151abb7a9">supported_by_runtime_system</a> () const</td></tr>
<tr class="separator:a6cd8f7d8787c76e690ed9c4151abb7a9 inherit pub_methods_classsimdutf_1_1implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8555e398fd99b12d7af1305d43389980 inherit pub_methods_classsimdutf_1_1implementation" id="r_a8555e398fd99b12d7af1305d43389980"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacesimdutf.html#a6bd0ecc4f9b16b205f779497eef6bd59">encoding_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a8555e398fd99b12d7af1305d43389980">autodetect_encoding</a> (const char *input, size_t length) const noexcept</td></tr>
<tr class="separator:a8555e398fd99b12d7af1305d43389980 inherit pub_methods_classsimdutf_1_1implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abf7c84888017c3a05b529c050c7d22d2" id="r_abf7c84888017c3a05b529c050c7d22d2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsimdutf_1_1implementation.html">implementation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf7c84888017c3a05b529c050c7d22d2">set_best</a> () const noexcept</td></tr>
<tr class="separator:abf7c84888017c3a05b529c050c7d22d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classsimdutf_1_1implementation"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classsimdutf_1_1implementation')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsimdutf_1_1implementation.html">simdutf::implementation</a></td></tr>
<tr class="memitem:a5b82d70f2836bfd1e7f21b44ba9426d5 inherit pro_methods_classsimdutf_1_1implementation" id="r_a5b82d70f2836bfd1e7f21b44ba9426d5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5b82d70f2836bfd1e7f21b44ba9426d5">~implementation</a> ()=default</td></tr>
<tr class="separator:a5b82d70f2836bfd1e7f21b44ba9426d5 inherit pro_methods_classsimdutf_1_1implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Detects best supported implementation on first use, and sets it </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa9df59f306ae69bbada152b133d1c862" name="aa9df59f306ae69bbada152b133d1c862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9df59f306ae69bbada152b133d1c862">&#9670;&#160;</a></span>detect_best_supported_implementation_on_first_use()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a7a2290defcac825573ce84885fd832d2">simdutf_really_inline</a> simdutf::internal::detect_best_supported_implementation_on_first_use::detect_best_supported_implementation_on_first_use </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6a3bfb3e9a82cbd98d16b9a83d0e7a0c" name="a6a3bfb3e9a82cbd98d16b9a83d0e7a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3bfb3e9a82cbd98d16b9a83d0e7a0c">&#9670;&#160;</a></span>change_endianness_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdutf::internal::detect_best_supported_implementation_on_first_use::change_endianness_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the endianness of the input. Can be used to go from UTF-16LE to UTF-16BE or from UTF-16BE to UTF-16LE.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a8a342c5088a3b2887485836daa92628a">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a469fa08e37c2fdea426ec6721db9d17d" name="a469fa08e37c2fdea426ec6721db9d17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469fa08e37c2fdea426ec6721db9d17d">&#9670;&#160;</a></span>convert_latin1_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_latin1_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert Latin1 string into UTF-16BE string.</p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a2f498ad9236b916e5e4859109d1df0bb">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a4c90be09ea92641dfd759b72c098f948" name="a4c90be09ea92641dfd759b72c098f948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c90be09ea92641dfd759b72c098f948">&#9670;&#160;</a></span>convert_latin1_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_latin1_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly Latin1 string into UTF-16LE string.</p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a2315da3daf654f4a7132b1751394b374">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ad00ef8929e212338cbee01dbe5dcba41" name="ad00ef8929e212338cbee01dbe5dcba41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00ef8929e212338cbee01dbe5dcba41">&#9670;&#160;</a></span>convert_latin1_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_latin1_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert Latin1 string into UTF-32 string.</p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a5bb5a0db793a6e332711c24d9cbc14fd">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a37a256291fec86a378cca324280d44e6" name="a37a256291fec86a378cca324280d44e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a256291fec86a378cca324280d44e6">&#9670;&#160;</a></span>convert_latin1_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_latin1_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert Latin1 string into UTF8 string.</p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#af79deb79661a71f145b7bc6786fe4223">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a24963a2bf68d895d73e9d285fd63e298" name="a24963a2bf68d895d73e9d285fd63e298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24963a2bf68d895d73e9d285fd63e298">&#9670;&#160;</a></span>convert_utf16be_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16be_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ac941440407fed1518a179f1d0396720c">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a69fa0b0063bf1610ba3cf72246bd97ff" name="a69fa0b0063bf1610ba3cf72246bd97ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fa0b0063bf1610ba3cf72246bd97ff">&#9670;&#160;</a></span>convert_utf16be_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16be_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources. This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a29a8022ac1760f081d389cb00a4dac80">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a1d237f9f8ffc6263e24208aeb65be3c3" name="a1d237f9f8ffc6263e24208aeb65be3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d237f9f8ffc6263e24208aeb65be3c3">&#9670;&#160;</a></span>convert_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into UTF-32 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16BE string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a6297479226621edb24ffc30d642083d5">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a73bd3ee43d746068beb077459acb725f" name="a73bd3ee43d746068beb077459acb725f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bd3ee43d746068beb077459acb725f">&#9670;&#160;</a></span>convert_utf16be_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16be_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into UTF-32 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a78f306f07f9b0c88646629efc7672bfd">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ab5eed73d54da091fd0ec0908602724f1" name="ab5eed73d54da091fd0ec0908602724f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eed73d54da091fd0ec0908602724f1">&#9670;&#160;</a></span>convert_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into UTF-8 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16BE string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a4694517e0f22276fea37d154e35648e4">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a14955618e114ef69cba4eaa00c028bf3" name="a14955618e114ef69cba4eaa00c028bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14955618e114ef69cba4eaa00c028bf3">&#9670;&#160;</a></span>convert_utf16be_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16be_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a558db3f984286ccd44517a622f8cd676">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a45b856c2a8c7ae9ac022f9718436ba66" name="a45b856c2a8c7ae9ac022f9718436ba66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b856c2a8c7ae9ac022f9718436ba66">&#9670;&#160;</a></span>convert_utf16le_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16le_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a75f16dc0f3bdd4457425898a17c51d45">simdutf::implementation</a>.</p>

</div>
</div>
<a id="abddadc05af70ed6f56fa25c0491292ce" name="abddadc05af70ed6f56fa25c0491292ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abddadc05af70ed6f56fa25c0491292ce">&#9670;&#160;</a></span>convert_utf16le_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16le_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources. This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a4aa4c4b831e691e623552bbf9c60b801">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a78ace21b2351a224ea07aaf7a8b31044" name="a78ace21b2351a224ea07aaf7a8b31044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ace21b2351a224ea07aaf7a8b31044">&#9670;&#160;</a></span>convert_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into UTF-32 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a0fcdaa10985d51cd8f533c41d03c7ce0">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aaf31e9fb10899f000e153238f158cd53" name="aaf31e9fb10899f000e153238f158cd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf31e9fb10899f000e153238f158cd53">&#9670;&#160;</a></span>convert_utf16le_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16le_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into UTF-32 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ab53d42cf1525497c67690667242b669d">simdutf::implementation</a>.</p>

</div>
</div>
<a id="acce5ecaf602f39cd5321c5de6bf3439d" name="acce5ecaf602f39cd5321c5de6bf3439d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce5ecaf602f39cd5321c5de6bf3439d">&#9670;&#160;</a></span>convert_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into UTF-8 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#abca86864832acad7c1277e6675c73e58">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aa6fa33d08a81f6b5a7977f1b4d436a41" name="aa6fa33d08a81f6b5a7977f1b4d436a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fa33d08a81f6b5a7977f1b4d436a41">&#9670;&#160;</a></span>convert_utf16le_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf16le_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a77cb2f67aadb85bb3c64789f3d501d8b">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a36dc55a151b331491752212f83328467" name="a36dc55a151b331491752212f83328467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dc55a151b331491752212f83328467">&#9670;&#160;</a></span>convert_utf32_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf32_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a66c1ec7808c2572670b540cd3ccce6b1">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aac3bea933438d4e0ad2c51a32e64a636" name="aac3bea933438d4e0ad2c51a32e64a636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3bea933438d4e0ad2c51a32e64a636">&#9670;&#160;</a></span>convert_utf32_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf32_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into Latin1 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a2d067614ecf86f2e7a6dfa2158567677">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ac5fbb8adcdc91b67e528c90c54e88f36" name="ac5fbb8adcdc91b67e528c90c54e88f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fbb8adcdc91b67e528c90c54e88f36">&#9670;&#160;</a></span>convert_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-16BE string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a7f90a3a4b12a2e361618fb3e9e4b5cbd">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ac3a755aa8cc56b32fb0aa1b0e3079b79" name="ac3a755aa8cc56b32fb0aa1b0e3079b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a755aa8cc56b32fb0aa1b0e3079b79">&#9670;&#160;</a></span>convert_utf32_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf32_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-16BE string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a3eed63c72cb1a7736ecb96f149d0ae6f">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a71ae3cc379e513b93a6a8eed91f00412" name="a71ae3cc379e513b93a6a8eed91f00412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ae3cc379e513b93a6a8eed91f00412">&#9670;&#160;</a></span>convert_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-16LE string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a342d098f7c92e8344944dfa947daa66d">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a7b7fb2084883c8d5ed27c8faf46d57e8" name="a7b7fb2084883c8d5ed27c8faf46d57e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7fb2084883c8d5ed27c8faf46d57e8">&#9670;&#160;</a></span>convert_utf32_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf32_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-16LE string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#af760d6a771de56c57588241cb01b597f">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a7a823aa90e1a7d7f644b5ba7cb671297" name="a7a823aa90e1a7d7f644b5ba7cb671297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a823aa90e1a7d7f644b5ba7cb671297">&#9670;&#160;</a></span>convert_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-8 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ac5ba1394d1cb70ff61ff9e10fec2b4ae">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a45b091a5f54877c92e10b1dd5178907c" name="a45b091a5f54877c92e10b1dd5178907c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b091a5f54877c92e10b1dd5178907c">&#9670;&#160;</a></span>convert_utf32_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf32_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-8 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ad868e852d46a46b631524f2a4bb5f31d">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aca5f4d773e8a863c364c74338b216300" name="aca5f4d773e8a863c364c74338b216300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5f4d773e8a863c364c74338b216300">&#9670;&#160;</a></span>convert_utf8_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf8_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if the input was not valid UTF-8 string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ac9c2c1418f08f84e36c22727879db307">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ac8c19ed979e4a43f5450970cdaa04332" name="ac8c19ed979e4a43f5450970cdaa04332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c19ed979e4a43f5450970cdaa04332">&#9670;&#160;</a></span>convert_utf8_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf8_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into latin1 string with errors</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ae845d016f715c25475970c4dfcb58a8d">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a68a22a82092f1e449028ae73890bf140" name="a68a22a82092f1e449028ae73890bf140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a22a82092f1e449028ae73890bf140">&#9670;&#160;</a></span>convert_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-16BE string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a0eb08f6b1d102dd298f3d265615b21aa">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a0f09d5277d40a7c3f853267854279908" name="a0f09d5277d40a7c3f853267854279908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f09d5277d40a7c3f853267854279908">&#9670;&#160;</a></span>convert_utf8_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf8_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ae18e1b44673966d2f058524700d41db0">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a634081878fde335d096214412a340145" name="a634081878fde335d096214412a340145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634081878fde335d096214412a340145">&#9670;&#160;</a></span>convert_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-16LE string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a487615c5d6dc00183fdf6a904bd829dc">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ac7c2b3cac02ccd52bec3e05c53a77bf6" name="ac7c2b3cac02ccd52bec3e05c53a77bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c2b3cac02ccd52bec3e05c53a77bf6">&#9670;&#160;</a></span>convert_utf8_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf8_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a6091f1fbcaf897575af907ab8896d151">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a18801cca96d630b0657a26953775f3e6" name="a18801cca96d630b0657a26953775f3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18801cca96d630b0657a26953775f3e6">&#9670;&#160;</a></span>convert_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-32 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#aab894ce236190e9cc71e0ce1602bbc60">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a5b0bddef27f14274b402e1cb0c5653f3" name="a5b0bddef27f14274b402e1cb0c5653f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0bddef27f14274b402e1cb0c5653f3">&#9670;&#160;</a></span>convert_utf8_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::convert_utf8_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-32 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a5c5166f22c16902452eec6a93ad7a926">simdutf::implementation</a>.</p>

</div>
</div>
<a id="abdc0acabc47a2307ddf7c889f23c7e2d" name="abdc0acabc47a2307ddf7c889f23c7e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc0acabc47a2307ddf7c889f23c7e2d">&#9670;&#160;</a></span>convert_valid_utf16be_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf16be_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16BE string into Latin1 string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a6896e27fd7fe773ba25bfaed081aafaa">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a6a0a017ed6ae898e12ec8eda1c87ceb5" name="a6a0a017ed6ae898e12ec8eda1c87ceb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0a017ed6ae898e12ec8eda1c87ceb5">&#9670;&#160;</a></span>convert_valid_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16LE string into UTF-32BE string.</p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a15e91ad7be0d09f713283d33105a4939">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a3811bfe7062a30586d5aab5d6ece8ba6" name="a3811bfe7062a30586d5aab5d6ece8ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3811bfe7062a30586d5aab5d6ece8ba6">&#9670;&#160;</a></span>convert_valid_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16BE string into UTF-8 string.</p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a204aff56bf36d384694a5b5e73ddc579">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a75da7cc61fdb5d736b05d23fff356f2b" name="a75da7cc61fdb5d736b05d23fff356f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75da7cc61fdb5d736b05d23fff356f2b">&#9670;&#160;</a></span>convert_valid_utf16le_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf16le_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16LE string into Latin1 string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a65c8a9e58f4c111d52851e4fdbca0af1">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a64a246bf9162caf68f65674e9b4cd987" name="a64a246bf9162caf68f65674e9b4cd987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a246bf9162caf68f65674e9b4cd987">&#9670;&#160;</a></span>convert_valid_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16LE string into UTF-32 string.</p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a2bd5db8c4f3f4b6055497138f8cec860">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a9432ea0e2328c0c9f2aab784a4186430" name="a9432ea0e2328c0c9f2aab784a4186430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9432ea0e2328c0c9f2aab784a4186430">&#9670;&#160;</a></span>convert_valid_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16LE string into UTF-8 string.</p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a3d5ab12b92ea57e2b88af5b19118833b">simdutf::implementation</a>.</p>

</div>
</div>
<a id="af22e574e388f8b4523f685e71ddf7d99" name="af22e574e388f8b4523f685e71ddf7d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22e574e388f8b4523f685e71ddf7d99">&#9670;&#160;</a></span>convert_valid_utf32_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf32_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-32 string into Latin1 string.</p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a00b1ec570f19982c826e2b04b501a1ac">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aace6ca098d9f8e6f40fb9986c124d5cc" name="aace6ca098d9f8e6f40fb9986c124d5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace6ca098d9f8e6f40fb9986c124d5cc">&#9670;&#160;</a></span>convert_valid_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-32 string into UTF-16BE string.</p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a38557c96a34c9cc87f7294aca0538582">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a9143c5ec5c9f912960a00d0fe39c8f5f" name="a9143c5ec5c9f912960a00d0fe39c8f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9143c5ec5c9f912960a00d0fe39c8f5f">&#9670;&#160;</a></span>convert_valid_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-32 string into UTF-16LE string.</p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a9f8ccb48c01e7f93480e9bdd7fb3beee">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aa22e626921c1e78335fdc13ed3a28f6a" name="aa22e626921c1e78335fdc13ed3a28f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22e626921c1e78335fdc13ed3a28f6a">&#9670;&#160;</a></span>convert_valid_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-32 string into UTF-8 string.</p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a5d859ac6b4327e3155f1accef2f42c23">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a335e4d43cd4e7601231e0c96b85f9f64" name="a335e4d43cd4e7601231e0c96b85f9f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335e4d43cd4e7601231e0c96b85f9f64">&#9670;&#160;</a></span>convert_valid_utf8_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf8_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_output</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-8 string into latin1 string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if the input was not valid UTF-8 string </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a903279159cb5f5e0e767cce6f1440889">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a23ed4cd72a0d6f61163b7ead54222247" name="a23ed4cd72a0d6f61163b7ead54222247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ed4cd72a0d6f61163b7ead54222247">&#9670;&#160;</a></span>convert_valid_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-8 string into UTF-16BE string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a8d655f7769c5e5039821d512c116dc56">simdutf::implementation</a>.</p>

</div>
</div>
<a id="abeeda5e99a6b7eeeaae444c13b99d1d5" name="abeeda5e99a6b7eeeaae444c13b99d1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeeda5e99a6b7eeeaae444c13b99d1d5">&#9670;&#160;</a></span>convert_valid_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-8 string into UTF-16LE string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a08870586c80a46861a25c715323402c1">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aad35dd5a2909171aa932b8355c39b81b" name="aad35dd5a2909171aa932b8355c39b81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad35dd5a2909171aa932b8355c39b81b">&#9670;&#160;</a></span>convert_valid_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::convert_valid_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-8 string into UTF-32 string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a7566c1718e91a6d36b0c47822b0154ad">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ae2e112acca8b18bb40b64e8533b6e483" name="ae2e112acca8b18bb40b64e8533b6e483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e112acca8b18bb40b64e8533b6e483">&#9670;&#160;</a></span>count_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::count_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of code points (characters) in the string assuming that it is valid.</p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ad80712666d56ad7abb7cd8ea7862a4dd">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ad81f4ec3b85658c43d86d920544a9792" name="ad81f4ec3b85658c43d86d920544a9792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81f4ec3b85658c43d86d920544a9792">&#9670;&#160;</a></span>count_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::count_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of code points (characters) in the string assuming that it is valid.</p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a612381e291d6a957707defcba3c5d4aa">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ae32020409f7ecdee625f9c6db83f5828" name="ae32020409f7ecdee625f9c6db83f5828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32020409f7ecdee625f9c6db83f5828">&#9670;&#160;</a></span>count_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::count_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of code points (characters) in the string assuming that it is valid.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a380f5ef4b282ef66210a84ebc84bce51">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ac391010f27fed7f369fec1da303b6df9" name="ac391010f27fed7f369fec1da303b6df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac391010f27fed7f369fec1da303b6df9">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; simdutf::internal::detect_best_supported_implementation_on_first_use::description </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The description of this implementation. </p><pre class="fragment">const implementation *impl = simdutf::active_implementation;
cout &lt;&lt; "simdutf is optimized for " &lt;&lt; impl-&gt;name() &lt;&lt; "(" &lt;&lt; impl-&gt;description() &lt;&lt; ")" &lt;&lt; endl;
</pre> <dl class="section return"><dt>Returns</dt><dd>the name of the implementation, e.g. "haswell", "westmere", "arm64" </dd></dl>

<p>Reimplemented from <a class="el" href="classsimdutf_1_1implementation.html#ae46f81ce83121738fa18ddcadd5f4e61">simdutf::implementation</a>.</p>

</div>
</div>
<a id="adc43e4df43d667395a1e7237093d5ef2" name="adc43e4df43d667395a1e7237093d5ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc43e4df43d667395a1e7237093d5ef2">&#9670;&#160;</a></span>detect_encodings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> int simdutf::internal::detect_best_supported_implementation_on_first_use::detect_encodings </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will try to detect the possible encodings in one pass </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the string to identify </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoding type detected </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ad4a7dbe2fbc9d03da2542c07a88cdddb">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aaa4faf763d24adebb4ec372444499a56" name="aaa4faf763d24adebb4ec372444499a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4faf763d24adebb4ec372444499a56">&#9670;&#160;</a></span>latin1_length_from_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::latin1_length_from_utf16 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a83aed89399b43b6f7a36172f3af38b99">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a2b17c8be393e435246252036f6c3ed0e" name="a2b17c8be393e435246252036f6c3ed0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b17c8be393e435246252036f6c3ed0e">&#9670;&#160;</a></span>latin1_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::latin1_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-32 string would require in Latin1 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as Latin1 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a6936dace0dfd89741259cdbe49b5df2d">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a3debe4483b6170bba9ad6045ee74a95a" name="a3debe4483b6170bba9ad6045ee74a95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3debe4483b6170bba9ad6045ee74a95a">&#9670;&#160;</a></span>latin1_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::latin1_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-8 string would require in Latin1 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-8 string as Latin1 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a2cc04b416c87dfa742056ce5bd8033dc">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a88e4337bb6248cbf1c470949cba19968" name="a88e4337bb6248cbf1c470949cba19968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e4337bb6248cbf1c470949cba19968">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; simdutf::internal::detect_best_supported_implementation_on_first_use::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of this implementation. </p><pre class="fragment">const implementation *impl = simdutf::active_implementation;
cout &lt;&lt; "simdutf is optimized for " &lt;&lt; impl-&gt;name() &lt;&lt; "(" &lt;&lt; impl-&gt;description() &lt;&lt; ")" &lt;&lt; endl;
</pre> <dl class="section return"><dt>Returns</dt><dd>the name of the implementation, e.g. "haswell", "westmere", "arm64" </dd></dl>

<p>Reimplemented from <a class="el" href="classsimdutf_1_1implementation.html#a1fbe547f256a016cf45f17667dc980c0">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ada52e4977bb9fb646b4d8fa47fb915bc" name="ada52e4977bb9fb646b4d8fa47fb915bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada52e4977bb9fb646b4d8fa47fb915bc">&#9670;&#160;</a></span>required_instruction_sets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t simdutf::internal::detect_best_supported_implementation_on_first_use::required_instruction_sets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For internal implementation use</p>
<p>The instruction sets this implementation is compiled against.</p>
<dl class="section return"><dt>Returns</dt><dd>a mask of all required <code><a class="el" href="namespacesimdutf_1_1internal.html#ac4f155d3cd7620e86db7e06af11d1d73">internal::instruction_set</a>::</code> values </dd></dl>

<p>Reimplemented from <a class="el" href="classsimdutf_1_1implementation.html#a78a22eb6c2b2402902d677b8dba3ae03">simdutf::implementation</a>.</p>

</div>
</div>
<a id="abf7c84888017c3a05b529c050c7d22d2" name="abf7c84888017c3a05b529c050c7d22d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7c84888017c3a05b529c050c7d22d2">&#9670;&#160;</a></span>set_best()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsimdutf_1_1implementation.html">implementation</a> * simdutf::internal::detect_best_supported_implementation_on_first_use::set_best </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa184a01c73ac096bbf83f29f4a4d8da9" name="aa184a01c73ac096bbf83f29f4a4d8da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa184a01c73ac096bbf83f29f4a4d8da9">&#9670;&#160;</a></span>utf16_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf16_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of bytes that this UTF-16 string would require in Latin1 format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16 string as Latin1 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a4b211eefd837bfb9c080df56c408c3d4">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a66f87ab088fbf0a0fa3fbf82b62068d0" name="a66f87ab088fbf0a0fa3fbf82b62068d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f87ab088fbf0a0fa3fbf82b62068d0">&#9670;&#160;</a></span>utf16_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf16_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of two-byte code units that this UTF-32 string would require in UTF-16 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-16 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a3761299ce52ee8b2b480fcadc50b45a5">simdutf::implementation</a>.</p>

</div>
</div>
<a id="afd70ceb346095a22c1873f9a9708916e" name="afd70ceb346095a22c1873f9a9708916e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd70ceb346095a22c1873f9a9708916e">&#9670;&#160;</a></span>utf16_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf16_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of 2-byte code units that this UTF-8 string would require in UTF-16LE format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char16_t code units required to encode the UTF-8 string as UTF-16LE </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ae01141d4bf774c95e771924caa11efb1">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ab85167a96d66ce919f41b322fbed167e" name="ab85167a96d66ce919f41b322fbed167e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85167a96d66ce919f41b322fbed167e">&#9670;&#160;</a></span>utf32_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf32_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of bytes that this UTF-32 string would require in Latin1 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as Latin1 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a8039edd257c0f2bdf1acc5d16476992a">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a7d5cbf67bbf9d5f03c303431f64c9cd6" name="a7d5cbf67bbf9d5f03c303431f64c9cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5cbf67bbf9d5f03c303431f64c9cd6">&#9670;&#160;</a></span>utf32_length_from_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf32_length_from_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a0df5efd699e928178cb569ee2b9b0711">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a725be9fee94eeae7697e9a0ec433f2d9" name="a725be9fee94eeae7697e9a0ec433f2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725be9fee94eeae7697e9a0ec433f2d9">&#9670;&#160;</a></span>utf32_length_from_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf32_length_from_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a83b225db7024f73fdcd6f84fb10ecdfe">simdutf::implementation</a>.</p>

</div>
</div>
<a id="ab8155d51fc6d5ea1ab54288888474500" name="ab8155d51fc6d5ea1ab54288888474500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8155d51fc6d5ea1ab54288888474500">&#9670;&#160;</a></span>utf32_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf32_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of 4-byte code units that this UTF-8 string would require in UTF-32 format.</p>
<p>This function is equivalent to count_utf8.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char32_t code units required to encode the UTF-8 string as UTF-32 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a39bc047dd50ede9cd33cb7e825eb5b56">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a0b5c8377089b339a40b2f87ab2bd25b5" name="a0b5c8377089b339a40b2f87ab2bd25b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5c8377089b339a40b2f87ab2bd25b5">&#9670;&#160;</a></span>utf8_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf8_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of bytes that this Latin1 string would require in UTF-8 format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the Latin1 string as UTF-8 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#aff358bb1f0b909cd1e9a6227656ee5d7">simdutf::implementation</a>.</p>

</div>
</div>
<a id="adc9a6b38142dc8ffdcbb7b97931d45ee" name="adc9a6b38142dc8ffdcbb7b97931d45ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9a6b38142dc8ffdcbb7b97931d45ee">&#9670;&#160;</a></span>utf8_length_from_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf8_length_from_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-16BE string would require in UTF-8 format.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16BE string as UTF-8 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#abce2ef1ff8ab5ffd3999d545f703a2fd">simdutf::implementation</a>.</p>

</div>
</div>
<a id="af9fd0def796bd23d1b127472426832d6" name="af9fd0def796bd23d1b127472426832d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fd0def796bd23d1b127472426832d6">&#9670;&#160;</a></span>utf8_length_from_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf8_length_from_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-16LE string would require in UTF-8 format.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as UTF-8 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a446248e71fc872b071d25a27673139f5">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a796316128259e64fb520343283d83136" name="a796316128259e64fb520343283d83136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796316128259e64fb520343283d83136">&#9670;&#160;</a></span>utf8_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::internal::detect_best_supported_implementation_on_first_use::utf8_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-32 string would require in UTF-8 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-8 </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a2f39ff7d49c8864a9035c626825edad0">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a3f5a644cc8682c969426b924578d89e5" name="a3f5a644cc8682c969426b924578d89e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5a644cc8682c969426b924578d89e5">&#9670;&#160;</a></span>validate_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::internal::detect_best_supported_implementation_on_first_use::validate_ascii </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the ASCII string.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid ASCII. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#adde94939db547675113aa71ec979d2ce">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aa7af57e80f8de7a3edcaa20254bb496a" name="aa7af57e80f8de7a3edcaa20254bb496a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7af57e80f8de7a3edcaa20254bb496a">&#9670;&#160;</a></span>validate_ascii_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::validate_ascii_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the ASCII string and stop on error.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#aa73e0b4e751f59a6f67c0bde3e503e23">simdutf::implementation</a>.</p>

</div>
</div>
<a id="aa1a9696d74e33f200c7e5e3f2d7bc6b8" name="aa1a9696d74e33f200c7e5e3f2d7bc6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a9696d74e33f200c7e5e3f2d7bc6b8">&#9670;&#160;</a></span>validate_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::internal::detect_best_supported_implementation_on_first_use::validate_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-16BE string. This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf16be_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16BE. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a27a221cf4c4d195d110387d10bbd4b33">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a05ff9db850ed25ca6a3a33fb8852bda1" name="a05ff9db850ed25ca6a3a33fb8852bda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ff9db850ed25ca6a3a33fb8852bda1">&#9670;&#160;</a></span>validate_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::validate_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-16BE string and stop on error. It might be faster than validate_utf16be when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a7632c87e825c7f268cbb787612e940bf">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a14843f8f297ebc612066b307d7aeeb70" name="a14843f8f297ebc612066b307d7aeeb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14843f8f297ebc612066b307d7aeeb70">&#9670;&#160;</a></span>validate_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::internal::detect_best_supported_implementation_on_first_use::validate_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-16LE string.This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf16le_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16LE. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a6047ac139bd2e8f6808a5bbd4b687629">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a8a94f2962cd848e2c15956b60f7bcdea" name="a8a94f2962cd848e2c15956b60f7bcdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a94f2962cd848e2c15956b60f7bcdea">&#9670;&#160;</a></span>validate_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::validate_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-16LE string and stop on error. It might be faster than validate_utf16le when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a53ce751bb24df472a93e4c36e8a1b03d">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a0c8bd6ba3cde34e40723f9b5930e2bad" name="a0c8bd6ba3cde34e40723f9b5930e2bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8bd6ba3cde34e40723f9b5930e2bad">&#9670;&#160;</a></span>validate_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::internal::detect_best_supported_implementation_on_first_use::validate_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-32 string.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte code units (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-32. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#ab35c6765b2e4b97cc97ab9f3af52c9a9">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a42a55750b9a99ea25b7d98934753f777" name="a42a55750b9a99ea25b7d98934753f777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a55750b9a99ea25b7d98934753f777">&#9670;&#160;</a></span>validate_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::validate_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-32 string and stop on error.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte code units (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a825ad7513447a16cd12f5425e2e88431">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a46169a17b9077b17ca2b5ae2133c3c56" name="a46169a17b9077b17ca2b5ae2133c3c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46169a17b9077b17ca2b5ae2133c3c56">&#9670;&#160;</a></span>validate_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::internal::detect_best_supported_implementation_on_first_use::validate_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-8 string.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-8. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#aaae969eb20db2099f92a504eb7db0bcf">simdutf::implementation</a>.</p>

</div>
</div>
<a id="a36f3886a54b3373b1021e2110234a3bf" name="a36f3886a54b3373b1021e2110234a3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f3886a54b3373b1021e2110234a3bf">&#9670;&#160;</a></span>validate_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::internal::detect_best_supported_implementation_on_first_use::validate_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-8 string and stop on errors.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

<p>Implements <a class="el" href="classsimdutf_1_1implementation.html#a42f53d3a9e9112a7ad4dfe67cfeccf07">simdutf::implementation</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/assetmgr/<a class="el" href="simdutf_8cpp.html">simdutf.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimdutf.html">simdutf</a></li><li class="navelem"><a class="el" href="namespacesimdutf_1_1internal.html">internal</a></li><li class="navelem"><a class="el" href="classsimdutf_1_1internal_1_1detect__best__supported__implementation__on__first__use.html">detect_best_supported_implementation_on_first_use</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
