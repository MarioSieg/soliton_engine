<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lunam Engine: simdutf Namespace Reference</title>
<link rel="icon" href="logo_small.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Lunam Engine
   </div>
   <div id="projectbrief">Realtime Simulation Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacesimdutf.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">simdutf Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesimdutf_1_1_b_o_m" id="r_namespacesimdutf_1_1_b_o_m"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesimdutf_1_1_b_o_m.html">BOM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesimdutf_1_1fallback" id="r_namespacesimdutf_1_1fallback"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesimdutf_1_1fallback.html">fallback</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesimdutf_1_1internal" id="r_namespacesimdutf_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesimdutf_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesimdutf_1_1scalar" id="r_namespacesimdutf_1_1scalar"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesimdutf_1_1scalar.html">scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesimdutf_1_1tables" id="r_namespacesimdutf_1_1tables"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesimdutf_1_1tables.html">tables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html">implementation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimdutf_1_1result.html">result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6bd0ecc4f9b16b205f779497eef6bd59" id="r_a6bd0ecc4f9b16b205f779497eef6bd59"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59">encoding_type</a> { <br />
&#160;&#160;<a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a917dc582783b964eaac058d213dffd26">UTF8</a> = 1
, <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a6ae826657cdafba0b4efc38fd73c8d7e">UTF16_LE</a> = 2
, <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a690fe2b3b619d0d5d75b25db6ed6ab30">UTF16_BE</a> = 4
, <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a3ad7dfaaa28f2f00dbabca345fcd6147">UTF32_LE</a> = 8
, <br />
&#160;&#160;<a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a1311591f943599c3aa8c42797f3b3471">UTF32_BE</a> = 16
, <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a053aab5ec8acf4476abaee782ebf21f9">Latin1</a> = 32
, <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a93bd32959bf7e245a48602fb04068373">unspecified</a> = 0
<br />
 }</td></tr>
<tr class="separator:a6bd0ecc4f9b16b205f779497eef6bd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfa8a9b32b9b52abbdde7c458290fb9" id="r_a4bfa8a9b32b9b52abbdde7c458290fb9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bfa8a9b32b9b52abbdde7c458290fb9">endianness</a> { <a class="el" href="#a4bfa8a9b32b9b52abbdde7c458290fb9a5ac03fc4a9023316a738bb8d41b20390">LITTLE</a> = 0
, <a class="el" href="#a4bfa8a9b32b9b52abbdde7c458290fb9ab3e432f36f75731ead119b4b32a5082d">BIG</a> = 1
 }</td></tr>
<tr class="separator:a4bfa8a9b32b9b52abbdde7c458290fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bb9bd60cb20c3c7912cd6731819f9e" id="r_a21bb9bd60cb20c3c7912cd6731819f9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9e">error_code</a> { <br />
&#160;&#160;<a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9eaefb7e6a3372b5b35515184a9ae6ff555">SUCCESS</a> = 0
, <a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9ea700595b55a7f9863f3efee4cb8d81fc0">HEADER_BITS</a>
, <a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9ea0c333e47a4a04d36b6360c53b34eab95">TOO_SHORT</a>
, <a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9ea962d7aef8a0a173ad59a70ffe2d4b58c">TOO_LONG</a>
, <br />
&#160;&#160;<a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9ea25ff959549dda532a96298ccc63425d6">OVERLONG</a>
, <a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9ea2b72249220a281461ace00f6d4c0852d">TOO_LARGE</a>
, <a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9eaf3ab787bae3a3cb50a7b6b839dd10344">SURROGATE</a>
, <a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9ea9954c243b4cc61391de250c437123e09">OTHER</a>
<br />
 }</td></tr>
<tr class="separator:a21bb9bd60cb20c3c7912cd6731819f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7a78ed9afc42fba5adfc42e200c3de" id="r_a7d7a78ed9afc42fba5adfc42e200c3de"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="#a7d7a78ed9afc42fba5adfc42e200c3dea0f1ce753edf47d790870b3e710520f02">SIMDUTF_VERSION_MAJOR</a> = 4
, <a class="el" href="#a7d7a78ed9afc42fba5adfc42e200c3deabeaedb9d209c037a199b6a9039c79b46">SIMDUTF_VERSION_MINOR</a> = 0
, <a class="el" href="#a7d7a78ed9afc42fba5adfc42e200c3deadff56e8290b4b8fc340a95ecbededae2">SIMDUTF_VERSION_REVISION</a> = 8
 }</td></tr>
<tr class="separator:a7d7a78ed9afc42fba5adfc42e200c3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a447e9efa7338521159ba175edab76759" id="r_a447e9efa7338521159ba175edab76759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a5e25f8d632d07af7b61d9174d2461ba4">SIMDUTF_DLLIMPORTEXPORT</a> const <a class="el" href="classsimdutf_1_1internal_1_1available__implementation__list.html">internal::available_implementation_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a447e9efa7338521159ba175edab76759">get_available_implementations</a> ()</td></tr>
<tr class="separator:a447e9efa7338521159ba175edab76759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f77c56a51f2c53ddaf5d29d7995483" id="r_a26f77c56a51f2c53ddaf5d29d7995483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a5e25f8d632d07af7b61d9174d2461ba4">SIMDUTF_DLLIMPORTEXPORT</a> <a class="el" href="classsimdutf_1_1internal_1_1atomic__ptr.html">internal::atomic_ptr</a>&lt; const <a class="el" href="classsimdutf_1_1implementation.html">implementation</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26f77c56a51f2c53ddaf5d29d7995483">get_active_implementation</a> ()</td></tr>
<tr class="separator:a26f77c56a51f2c53ddaf5d29d7995483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3088077c0230659012b58fd3b783c1" id="r_a5d3088077c0230659012b58fd3b783c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d3088077c0230659012b58fd3b783c1">validate_utf8</a> (const char *buf, size_t len) noexcept</td></tr>
<tr class="separator:a5d3088077c0230659012b58fd3b783c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909de1285ace38031be40fce13465509" id="r_a909de1285ace38031be40fce13465509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a909de1285ace38031be40fce13465509">validate_utf8_with_errors</a> (const char *buf, size_t len) noexcept</td></tr>
<tr class="separator:a909de1285ace38031be40fce13465509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69c6eef367452f03ae298a6b4a4772d" id="r_af69c6eef367452f03ae298a6b4a4772d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69c6eef367452f03ae298a6b4a4772d">validate_ascii</a> (const char *buf, size_t len) noexcept</td></tr>
<tr class="separator:af69c6eef367452f03ae298a6b4a4772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8517cb96f285347e5312f95b72fa6e" id="r_aee8517cb96f285347e5312f95b72fa6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee8517cb96f285347e5312f95b72fa6e">validate_ascii_with_errors</a> (const char *buf, size_t len) noexcept</td></tr>
<tr class="separator:aee8517cb96f285347e5312f95b72fa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0932d08526cecb7bdc7e5a3411ec5bf" id="r_af0932d08526cecb7bdc7e5a3411ec5bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0932d08526cecb7bdc7e5a3411ec5bf">convert_utf8_to_utf16</a> (const char *input, size_t length, char16_t *utf16_output) noexcept</td></tr>
<tr class="separator:af0932d08526cecb7bdc7e5a3411ec5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9107a119fd2a80906c63fdb2eee511ad" id="r_a9107a119fd2a80906c63fdb2eee511ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9107a119fd2a80906c63fdb2eee511ad">convert_latin1_to_utf8</a> (const char *buf, size_t len, char *utf8_output) noexcept</td></tr>
<tr class="separator:a9107a119fd2a80906c63fdb2eee511ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7942e1b1791ddba4afd565d85af7dc28" id="r_a7942e1b1791ddba4afd565d85af7dc28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7942e1b1791ddba4afd565d85af7dc28">convert_latin1_to_utf16le</a> (const char *buf, size_t len, char16_t *utf16_output) noexcept</td></tr>
<tr class="separator:a7942e1b1791ddba4afd565d85af7dc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea36e1bfc7301e764986e8774a613c96" id="r_aea36e1bfc7301e764986e8774a613c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea36e1bfc7301e764986e8774a613c96">convert_latin1_to_utf16be</a> (const char *buf, size_t len, char16_t *utf16_output) noexcept</td></tr>
<tr class="separator:aea36e1bfc7301e764986e8774a613c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6de840d05d27b1e8f0649e52108e56a" id="r_ab6de840d05d27b1e8f0649e52108e56a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6de840d05d27b1e8f0649e52108e56a">convert_latin1_to_utf32</a> (const char *buf, size_t len, char32_t *latin1_output) noexcept</td></tr>
<tr class="separator:ab6de840d05d27b1e8f0649e52108e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7a8e316f2f94801142d44b38d10b1b" id="r_afc7a8e316f2f94801142d44b38d10b1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc7a8e316f2f94801142d44b38d10b1b">convert_utf8_to_latin1</a> (const char *buf, size_t len, char *latin1_output) noexcept</td></tr>
<tr class="separator:afc7a8e316f2f94801142d44b38d10b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcec8602ed1ee544f4d914f37b99862a" id="r_afcec8602ed1ee544f4d914f37b99862a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcec8602ed1ee544f4d914f37b99862a">convert_utf8_to_latin1_with_errors</a> (const char *buf, size_t len, char *latin1_output) noexcept</td></tr>
<tr class="separator:afcec8602ed1ee544f4d914f37b99862a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7eff6ac225f4d972f941943e54f72e7" id="r_ad7eff6ac225f4d972f941943e54f72e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7eff6ac225f4d972f941943e54f72e7">convert_valid_utf8_to_latin1</a> (const char *buf, size_t len, char *latin1_output) noexcept</td></tr>
<tr class="separator:ad7eff6ac225f4d972f941943e54f72e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4b9db9d1c9f4093fb3564b5991f51a" id="r_a2b4b9db9d1c9f4093fb3564b5991f51a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b4b9db9d1c9f4093fb3564b5991f51a">convert_utf8_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_output) noexcept</td></tr>
<tr class="separator:a2b4b9db9d1c9f4093fb3564b5991f51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6451d4e382ae7b363cc9e2f024483bc" id="r_ad6451d4e382ae7b363cc9e2f024483bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6451d4e382ae7b363cc9e2f024483bc">convert_utf8_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_output) noexcept</td></tr>
<tr class="separator:ad6451d4e382ae7b363cc9e2f024483bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830e4736fb947da8630fd5789de02821" id="r_a830e4736fb947da8630fd5789de02821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a830e4736fb947da8630fd5789de02821">convert_utf8_to_utf16_with_errors</a> (const char *input, size_t length, char16_t *utf16_output) noexcept</td></tr>
<tr class="separator:a830e4736fb947da8630fd5789de02821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bee7068da946ea620e75f73496a539" id="r_a51bee7068da946ea620e75f73496a539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51bee7068da946ea620e75f73496a539">convert_utf8_to_utf16le_with_errors</a> (const char *input, size_t length, char16_t *utf16_output) noexcept</td></tr>
<tr class="separator:a51bee7068da946ea620e75f73496a539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856950cac4f430a8421b2ede923637fd" id="r_a856950cac4f430a8421b2ede923637fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a856950cac4f430a8421b2ede923637fd">convert_utf8_to_utf16be_with_errors</a> (const char *input, size_t length, char16_t *utf16_output) noexcept</td></tr>
<tr class="separator:a856950cac4f430a8421b2ede923637fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181598fd56783ba70fe28d5096293e2e" id="r_a181598fd56783ba70fe28d5096293e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a181598fd56783ba70fe28d5096293e2e">convert_utf8_to_utf32</a> (const char *input, size_t length, char32_t *utf32_output) noexcept</td></tr>
<tr class="separator:a181598fd56783ba70fe28d5096293e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf474179741fecc4c67047c39989bb99" id="r_aaf474179741fecc4c67047c39989bb99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf474179741fecc4c67047c39989bb99">convert_utf8_to_utf32_with_errors</a> (const char *input, size_t length, char32_t *utf32_output) noexcept</td></tr>
<tr class="separator:aaf474179741fecc4c67047c39989bb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d583d2142e4f818ca44b55cb7b492ef" id="r_a5d583d2142e4f818ca44b55cb7b492ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d583d2142e4f818ca44b55cb7b492ef">validate_utf16</a> (const char16_t *buf, size_t len) noexcept</td></tr>
<tr class="separator:a5d583d2142e4f818ca44b55cb7b492ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edbc803d79993e0a1aa8a1dd9cb587f" id="r_a0edbc803d79993e0a1aa8a1dd9cb587f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0edbc803d79993e0a1aa8a1dd9cb587f">validate_utf16le</a> (const char16_t *buf, size_t len) noexcept</td></tr>
<tr class="separator:a0edbc803d79993e0a1aa8a1dd9cb587f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f46e6de89a8eea5a55a0054e0dfbc6" id="r_a03f46e6de89a8eea5a55a0054e0dfbc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03f46e6de89a8eea5a55a0054e0dfbc6">validate_utf16be</a> (const char16_t *buf, size_t len) noexcept</td></tr>
<tr class="separator:a03f46e6de89a8eea5a55a0054e0dfbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9ef39df3b3c1e0d5c35e5be83e60b6" id="r_aae9ef39df3b3c1e0d5c35e5be83e60b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae9ef39df3b3c1e0d5c35e5be83e60b6">validate_utf16_with_errors</a> (const char16_t *buf, size_t len) noexcept</td></tr>
<tr class="separator:aae9ef39df3b3c1e0d5c35e5be83e60b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cb4b76c144be3877bccee498364125" id="r_ab0cb4b76c144be3877bccee498364125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0cb4b76c144be3877bccee498364125">validate_utf16le_with_errors</a> (const char16_t *buf, size_t len) noexcept</td></tr>
<tr class="separator:ab0cb4b76c144be3877bccee498364125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e8e0f72d343c0d140d4a73f24d74c4" id="r_a40e8e0f72d343c0d140d4a73f24d74c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40e8e0f72d343c0d140d4a73f24d74c4">validate_utf16be_with_errors</a> (const char16_t *buf, size_t len) noexcept</td></tr>
<tr class="separator:a40e8e0f72d343c0d140d4a73f24d74c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6f5318d1bbaa51e60d8975848f2a99" id="r_a6a6f5318d1bbaa51e60d8975848f2a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a6f5318d1bbaa51e60d8975848f2a99">validate_utf32</a> (const char32_t *buf, size_t len) noexcept</td></tr>
<tr class="separator:a6a6f5318d1bbaa51e60d8975848f2a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40f34e563a1c9989b876ff087eaacd8" id="r_ad40f34e563a1c9989b876ff087eaacd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40f34e563a1c9989b876ff087eaacd8">validate_utf32_with_errors</a> (const char32_t *buf, size_t len) noexcept</td></tr>
<tr class="separator:ad40f34e563a1c9989b876ff087eaacd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b12aa933318264f753a376008491a8e" id="r_a7b12aa933318264f753a376008491a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b12aa933318264f753a376008491a8e">convert_valid_utf8_to_utf16</a> (const char *input, size_t length, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:a7b12aa933318264f753a376008491a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4214bac8238956d9778766bfb3f486f" id="r_ad4214bac8238956d9778766bfb3f486f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4214bac8238956d9778766bfb3f486f">convert_valid_utf8_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:ad4214bac8238956d9778766bfb3f486f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724023c3f0ea36e4a18e06e13b575301" id="r_a724023c3f0ea36e4a18e06e13b575301"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a724023c3f0ea36e4a18e06e13b575301">convert_valid_utf8_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:a724023c3f0ea36e4a18e06e13b575301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373f28290220b972c49f53a7daf9243f" id="r_a373f28290220b972c49f53a7daf9243f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a373f28290220b972c49f53a7daf9243f">convert_valid_utf8_to_utf32</a> (const char *input, size_t length, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:a373f28290220b972c49f53a7daf9243f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f44eb6f8785e97e88d0677a847a430" id="r_a41f44eb6f8785e97e88d0677a847a430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41f44eb6f8785e97e88d0677a847a430">convert_utf16_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a41f44eb6f8785e97e88d0677a847a430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c4d3f0103d876f3886b9b63818652d" id="r_aa3c4d3f0103d876f3886b9b63818652d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3c4d3f0103d876f3886b9b63818652d">convert_utf16_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:aa3c4d3f0103d876f3886b9b63818652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c600c7480839057f59d37cd8d2dabd" id="r_a97c600c7480839057f59d37cd8d2dabd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c600c7480839057f59d37cd8d2dabd">convert_latin1_to_utf16</a> (const char *buf, size_t len, char16_t *utf16_output) noexcept</td></tr>
<tr class="separator:a97c600c7480839057f59d37cd8d2dabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbef7b3a8b34073ec4a6f6731a3c318" id="r_affbef7b3a8b34073ec4a6f6731a3c318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affbef7b3a8b34073ec4a6f6731a3c318">convert_utf16be_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:affbef7b3a8b34073ec4a6f6731a3c318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2649740b525188c2521002110052b43f" id="r_a2649740b525188c2521002110052b43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2649740b525188c2521002110052b43f">convert_utf16le_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:a2649740b525188c2521002110052b43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1240906d0aec98a1546af9354f9ab238" id="r_a1240906d0aec98a1546af9354f9ab238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1240906d0aec98a1546af9354f9ab238">convert_valid_utf16be_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:a1240906d0aec98a1546af9354f9ab238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d78799c134df9ac4cdcd7dfbc66608" id="r_a26d78799c134df9ac4cdcd7dfbc66608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26d78799c134df9ac4cdcd7dfbc66608">convert_valid_utf16le_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:a26d78799c134df9ac4cdcd7dfbc66608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa1cf3e743fb34b0cc3a9e46f3529ae" id="r_abfa1cf3e743fb34b0cc3a9e46f3529ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfa1cf3e743fb34b0cc3a9e46f3529ae">convert_utf16le_to_latin1_with_errors</a> (const char16_t *buf, size_t len, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:abfa1cf3e743fb34b0cc3a9e46f3529ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c25651c43a882706489f17a39b56ce0" id="r_a1c25651c43a882706489f17a39b56ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c25651c43a882706489f17a39b56ce0">convert_utf16be_to_latin1_with_errors</a> (const char16_t *buf, size_t len, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:a1c25651c43a882706489f17a39b56ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714aed8f48adc99a60baf00576f60a2c" id="r_a714aed8f48adc99a60baf00576f60a2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a714aed8f48adc99a60baf00576f60a2c">convert_utf16le_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a714aed8f48adc99a60baf00576f60a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf67034f0962cf04679d45df70e56c6" id="r_aebf67034f0962cf04679d45df70e56c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf67034f0962cf04679d45df70e56c6">convert_utf16be_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:aebf67034f0962cf04679d45df70e56c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6439cd96f125a50315bb102f4d23b396" id="r_a6439cd96f125a50315bb102f4d23b396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6439cd96f125a50315bb102f4d23b396">convert_utf16_to_utf8_with_errors</a> (const char16_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a6439cd96f125a50315bb102f4d23b396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95a683210b1de91f7f99691d0f3c6e1" id="r_aa95a683210b1de91f7f99691d0f3c6e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa95a683210b1de91f7f99691d0f3c6e1">convert_utf16_to_latin1_with_errors</a> (const char16_t *buf, size_t len, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:aa95a683210b1de91f7f99691d0f3c6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0277ce4834fc226877ff3b5eb9cbfce6" id="r_a0277ce4834fc226877ff3b5eb9cbfce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0277ce4834fc226877ff3b5eb9cbfce6">convert_utf16le_to_utf8_with_errors</a> (const char16_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a0277ce4834fc226877ff3b5eb9cbfce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611286f1d853f87d1dd9fe19c01297bb" id="r_a611286f1d853f87d1dd9fe19c01297bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a611286f1d853f87d1dd9fe19c01297bb">convert_utf16be_to_utf8_with_errors</a> (const char16_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a611286f1d853f87d1dd9fe19c01297bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52addf246254b2f622ba0e08ea0cbf9c" id="r_a52addf246254b2f622ba0e08ea0cbf9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52addf246254b2f622ba0e08ea0cbf9c">convert_valid_utf16_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a52addf246254b2f622ba0e08ea0cbf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c7059e0e2e517932297e34a2c9808d" id="r_a03c7059e0e2e517932297e34a2c9808d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03c7059e0e2e517932297e34a2c9808d">convert_valid_utf16_to_latin1</a> (const char16_t *buf, size_t len, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:a03c7059e0e2e517932297e34a2c9808d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e4da792a442f65b10eb5bb4afcf2b8" id="r_ae0e4da792a442f65b10eb5bb4afcf2b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0e4da792a442f65b10eb5bb4afcf2b8">convert_valid_utf16le_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:ae0e4da792a442f65b10eb5bb4afcf2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95134fa021602c8cdab4df88548c0aef" id="r_a95134fa021602c8cdab4df88548c0aef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95134fa021602c8cdab4df88548c0aef">convert_valid_utf16be_to_utf8</a> (const char16_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a95134fa021602c8cdab4df88548c0aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5102bcd1b8341b770c46a317c523fc" id="r_a4a5102bcd1b8341b770c46a317c523fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a5102bcd1b8341b770c46a317c523fc">convert_utf32_to_utf8</a> (const char32_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a4a5102bcd1b8341b770c46a317c523fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b082c3f3a7b837121530b95bdf802b" id="r_a89b082c3f3a7b837121530b95bdf802b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89b082c3f3a7b837121530b95bdf802b">convert_utf32_to_utf8_with_errors</a> (const char32_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a89b082c3f3a7b837121530b95bdf802b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2a8c972f8876b2e96fa32b839feacc" id="r_a0e2a8c972f8876b2e96fa32b839feacc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e2a8c972f8876b2e96fa32b839feacc">convert_valid_utf32_to_utf8</a> (const char32_t *buf, size_t len, char *utf8_buffer) noexcept</td></tr>
<tr class="separator:a0e2a8c972f8876b2e96fa32b839feacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae149859f89d6d04f0bac00ff0a6c225" id="r_aae149859f89d6d04f0bac00ff0a6c225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae149859f89d6d04f0bac00ff0a6c225">convert_utf32_to_utf16</a> (const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:aae149859f89d6d04f0bac00ff0a6c225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd03e0dec5d12445d0c1335e257c7d4e" id="r_acd03e0dec5d12445d0c1335e257c7d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd03e0dec5d12445d0c1335e257c7d4e">convert_utf32_to_latin1</a> (const char32_t *input, size_t length, char *latin1_output) noexcept</td></tr>
<tr class="separator:acd03e0dec5d12445d0c1335e257c7d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d60b7a75ee9c22ce6d6165cc8892a27" id="r_a7d60b7a75ee9c22ce6d6165cc8892a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d60b7a75ee9c22ce6d6165cc8892a27">convert_utf32_to_utf16le</a> (const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:a7d60b7a75ee9c22ce6d6165cc8892a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae537271d61cefaf0d66b77d6e2dcc204" id="r_ae537271d61cefaf0d66b77d6e2dcc204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae537271d61cefaf0d66b77d6e2dcc204">convert_utf32_to_utf16be</a> (const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:ae537271d61cefaf0d66b77d6e2dcc204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06ec3690a8fb376d3f89a0f6c43996a" id="r_ae06ec3690a8fb376d3f89a0f6c43996a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae06ec3690a8fb376d3f89a0f6c43996a">convert_utf32_to_utf16_with_errors</a> (const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:ae06ec3690a8fb376d3f89a0f6c43996a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a004fec5c7dac33e26f2485aec6ae4a" id="r_a5a004fec5c7dac33e26f2485aec6ae4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a004fec5c7dac33e26f2485aec6ae4a">convert_utf32_to_utf16le_with_errors</a> (const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:a5a004fec5c7dac33e26f2485aec6ae4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9968fe1877bd08c259d5472ee9387c85" id="r_a9968fe1877bd08c259d5472ee9387c85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9968fe1877bd08c259d5472ee9387c85">convert_utf32_to_utf16be_with_errors</a> (const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:a9968fe1877bd08c259d5472ee9387c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e331550c267fcab10956c419faab971" id="r_a8e331550c267fcab10956c419faab971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e331550c267fcab10956c419faab971">convert_valid_utf32_to_utf16</a> (const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:a8e331550c267fcab10956c419faab971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306ba01a7f899889203476834636c7b0" id="r_a306ba01a7f899889203476834636c7b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a306ba01a7f899889203476834636c7b0">convert_valid_utf32_to_utf16le</a> (const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:a306ba01a7f899889203476834636c7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12a863ee69a69bdcc5282e3c61e2e52" id="r_ab12a863ee69a69bdcc5282e3c61e2e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab12a863ee69a69bdcc5282e3c61e2e52">convert_valid_utf32_to_utf16be</a> (const char32_t *buf, size_t len, char16_t *utf16_buffer) noexcept</td></tr>
<tr class="separator:ab12a863ee69a69bdcc5282e3c61e2e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e8440ad72605456605de79305ca765" id="r_a36e8440ad72605456605de79305ca765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36e8440ad72605456605de79305ca765">convert_utf16_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:a36e8440ad72605456605de79305ca765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9e0688d52a327cf1c5b284289130c4" id="r_a2d9e0688d52a327cf1c5b284289130c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d9e0688d52a327cf1c5b284289130c4">convert_utf16le_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:a2d9e0688d52a327cf1c5b284289130c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172ce7d5cb1903ec81b79c22c7de9c17" id="r_a172ce7d5cb1903ec81b79c22c7de9c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a172ce7d5cb1903ec81b79c22c7de9c17">convert_utf16be_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:a172ce7d5cb1903ec81b79c22c7de9c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9ab41612aef151f0045aa51ff3dc63" id="r_a2e9ab41612aef151f0045aa51ff3dc63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e9ab41612aef151f0045aa51ff3dc63">convert_utf16_to_utf32_with_errors</a> (const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:a2e9ab41612aef151f0045aa51ff3dc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b08160058656bb26c0f7d5400017800" id="r_a3b08160058656bb26c0f7d5400017800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b08160058656bb26c0f7d5400017800">convert_utf16le_to_utf32_with_errors</a> (const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:a3b08160058656bb26c0f7d5400017800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72abf02976bc1f51bf174d219f012b9a" id="r_a72abf02976bc1f51bf174d219f012b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72abf02976bc1f51bf174d219f012b9a">convert_utf16be_to_utf32_with_errors</a> (const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:a72abf02976bc1f51bf174d219f012b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ce5bd7f4e3f5052a9b0ae7b84761bc" id="r_a25ce5bd7f4e3f5052a9b0ae7b84761bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25ce5bd7f4e3f5052a9b0ae7b84761bc">convert_valid_utf16_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:a25ce5bd7f4e3f5052a9b0ae7b84761bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410a780f6b16e03f8c185051db267d7d" id="r_a410a780f6b16e03f8c185051db267d7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a410a780f6b16e03f8c185051db267d7d">convert_valid_utf16le_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:a410a780f6b16e03f8c185051db267d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d3332f7c42911ff572fcb0e8458713" id="r_ab3d3332f7c42911ff572fcb0e8458713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3d3332f7c42911ff572fcb0e8458713">convert_valid_utf16be_to_utf32</a> (const char16_t *buf, size_t len, char32_t *utf32_buffer) noexcept</td></tr>
<tr class="separator:ab3d3332f7c42911ff572fcb0e8458713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469ead7666feebbe482f2af34aeb9746" id="r_a469ead7666feebbe482f2af34aeb9746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a469ead7666feebbe482f2af34aeb9746">change_endianness_utf16</a> (const char16_t *input, size_t length, char16_t *output) noexcept</td></tr>
<tr class="separator:a469ead7666feebbe482f2af34aeb9746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b56c9dfde1822d8b5f78105cee25e36" id="r_a7b56c9dfde1822d8b5f78105cee25e36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b56c9dfde1822d8b5f78105cee25e36">count_utf16</a> (const char16_t *input, size_t length) noexcept</td></tr>
<tr class="separator:a7b56c9dfde1822d8b5f78105cee25e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab94b40d9fecb4a04f1d0500f561da72" id="r_aab94b40d9fecb4a04f1d0500f561da72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab94b40d9fecb4a04f1d0500f561da72">count_utf16le</a> (const char16_t *input, size_t length) noexcept</td></tr>
<tr class="separator:aab94b40d9fecb4a04f1d0500f561da72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d0d4bc6e61b53d17bf944d2037c7f9" id="r_a58d0d4bc6e61b53d17bf944d2037c7f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58d0d4bc6e61b53d17bf944d2037c7f9">count_utf16be</a> (const char16_t *input, size_t length) noexcept</td></tr>
<tr class="separator:a58d0d4bc6e61b53d17bf944d2037c7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68327d86eea5cd68c673e699fd9fbedd" id="r_a68327d86eea5cd68c673e699fd9fbedd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68327d86eea5cd68c673e699fd9fbedd">count_utf8</a> (const char *input, size_t length) noexcept</td></tr>
<tr class="separator:a68327d86eea5cd68c673e699fd9fbedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1a84e9f930c74d0911bdf540e72d45" id="r_a4c1a84e9f930c74d0911bdf540e72d45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c1a84e9f930c74d0911bdf540e72d45">latin1_length_from_utf8</a> (const char *buf, size_t len) noexcept</td></tr>
<tr class="separator:a4c1a84e9f930c74d0911bdf540e72d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4766b9aa6062439b3187c26a58c4efbb" id="r_a4766b9aa6062439b3187c26a58c4efbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4766b9aa6062439b3187c26a58c4efbb">latin1_length_from_utf16</a> (size_t len) noexcept</td></tr>
<tr class="separator:a4766b9aa6062439b3187c26a58c4efbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9643b9547c15a476fcd31b16da4483b" id="r_ae9643b9547c15a476fcd31b16da4483b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9643b9547c15a476fcd31b16da4483b">latin1_length_from_utf32</a> (size_t len) noexcept</td></tr>
<tr class="separator:ae9643b9547c15a476fcd31b16da4483b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8715a943ff432d71c26da384cf32839" id="r_aa8715a943ff432d71c26da384cf32839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8715a943ff432d71c26da384cf32839">utf8_length_from_latin1</a> (const char *buf, size_t len) noexcept</td></tr>
<tr class="separator:aa8715a943ff432d71c26da384cf32839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94bd238016344ff84fc64dd59c11db8" id="r_af94bd238016344ff84fc64dd59c11db8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af94bd238016344ff84fc64dd59c11db8">utf8_length_from_utf16</a> (const char16_t *input, size_t length) noexcept</td></tr>
<tr class="separator:af94bd238016344ff84fc64dd59c11db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60198c318e878c68771e2af4c60fb0ab" id="r_a60198c318e878c68771e2af4c60fb0ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60198c318e878c68771e2af4c60fb0ab">utf8_length_from_utf16le</a> (const char16_t *input, size_t length) noexcept</td></tr>
<tr class="separator:a60198c318e878c68771e2af4c60fb0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7694416b37ad013dad68752afdfd7b44" id="r_a7694416b37ad013dad68752afdfd7b44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7694416b37ad013dad68752afdfd7b44">utf8_length_from_utf16be</a> (const char16_t *input, size_t length) noexcept</td></tr>
<tr class="separator:a7694416b37ad013dad68752afdfd7b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4457c6b706f3ef3cd37702582874640" id="r_ae4457c6b706f3ef3cd37702582874640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4457c6b706f3ef3cd37702582874640">utf32_length_from_utf16</a> (const char16_t *input, size_t length) noexcept</td></tr>
<tr class="separator:ae4457c6b706f3ef3cd37702582874640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194a30f90efb19fd5d4f5e04af490aec" id="r_a194a30f90efb19fd5d4f5e04af490aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a194a30f90efb19fd5d4f5e04af490aec">utf32_length_from_utf16le</a> (const char16_t *input, size_t length) noexcept</td></tr>
<tr class="separator:a194a30f90efb19fd5d4f5e04af490aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984ec93559ce641520d984aa6eb22973" id="r_a984ec93559ce641520d984aa6eb22973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a984ec93559ce641520d984aa6eb22973">utf32_length_from_utf16be</a> (const char16_t *input, size_t length) noexcept</td></tr>
<tr class="separator:a984ec93559ce641520d984aa6eb22973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997011ac59fd9c3667280d566599c2cb" id="r_a997011ac59fd9c3667280d566599c2cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a997011ac59fd9c3667280d566599c2cb">utf16_length_from_utf8</a> (const char *input, size_t length) noexcept</td></tr>
<tr class="separator:a997011ac59fd9c3667280d566599c2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d25502dcadef33d82564bdb7c16357" id="r_a01d25502dcadef33d82564bdb7c16357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01d25502dcadef33d82564bdb7c16357">utf16_length_from_latin1</a> (size_t length) noexcept</td></tr>
<tr class="separator:a01d25502dcadef33d82564bdb7c16357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f3924e36387a861736ae870ebf8721" id="r_a10f3924e36387a861736ae870ebf8721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10f3924e36387a861736ae870ebf8721">utf8_length_from_utf32</a> (const char32_t *input, size_t length) noexcept</td></tr>
<tr class="separator:a10f3924e36387a861736ae870ebf8721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe94e2686b242e2b818e8f33a8f3a9cb" id="r_afe94e2686b242e2b818e8f33a8f3a9cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe94e2686b242e2b818e8f33a8f3a9cb">utf16_length_from_utf32</a> (const char32_t *input, size_t length) noexcept</td></tr>
<tr class="separator:afe94e2686b242e2b818e8f33a8f3a9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905d22f0a789a77e69785956c49cf330" id="r_a905d22f0a789a77e69785956c49cf330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a905d22f0a789a77e69785956c49cf330">utf32_length_from_utf8</a> (const char *input, size_t length) noexcept</td></tr>
<tr class="separator:a905d22f0a789a77e69785956c49cf330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f6a8aee83ae995b7f3c88f7355d374" id="r_a92f6a8aee83ae995b7f3c88f7355d374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59">simdutf::encoding_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92f6a8aee83ae995b7f3c88f7355d374">autodetect_encoding</a> (const char *buf, size_t length) noexcept</td></tr>
<tr class="separator:a92f6a8aee83ae995b7f3c88f7355d374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5b2cd0b1d28ce104f92dbd39adeea8" id="r_abc5b2cd0b1d28ce104f92dbd39adeea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc5b2cd0b1d28ce104f92dbd39adeea8">detect_encodings</a> (const char *buf, size_t length) noexcept</td></tr>
<tr class="separator:abc5b2cd0b1d28ce104f92dbd39adeea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f85c5068e0dbfefce408c3bf8db0219" id="r_a3f85c5068e0dbfefce408c3bf8db0219"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsimdutf_1_1implementation.html">implementation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f85c5068e0dbfefce408c3bf8db0219">builtin_implementation</a> ()</td></tr>
<tr class="separator:a3f85c5068e0dbfefce408c3bf8db0219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee93cbcf7cf2f323d85233a4be0ad690" id="r_aee93cbcf7cf2f323d85233a4be0ad690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee93cbcf7cf2f323d85233a4be0ad690">trim_partial_utf8</a> (const char *input, size_t length)</td></tr>
<tr class="separator:aee93cbcf7cf2f323d85233a4be0ad690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf62a80eb3692e0cbd1c5f241a0976ac" id="r_acf62a80eb3692e0cbd1c5f241a0976ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf62a80eb3692e0cbd1c5f241a0976ac">trim_partial_utf16be</a> (const char16_t *input, size_t length)</td></tr>
<tr class="separator:acf62a80eb3692e0cbd1c5f241a0976ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9de79653f90a49a608f46c2c9932078" id="r_aa9de79653f90a49a608f46c2c9932078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9de79653f90a49a608f46c2c9932078">trim_partial_utf16le</a> (const char16_t *input, size_t length)</td></tr>
<tr class="separator:aa9de79653f90a49a608f46c2c9932078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776121f0f161fb2be1f7b6bc1dbbfb7b" id="r_a776121f0f161fb2be1f7b6bc1dbbfb7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a776121f0f161fb2be1f7b6bc1dbbfb7b">trim_partial_utf16</a> (const char16_t *input, size_t length)</td></tr>
<tr class="separator:a776121f0f161fb2be1f7b6bc1dbbfb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d330a76cf50d9e9c86f04694021444d" id="r_a1d330a76cf50d9e9c86f04694021444d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d330a76cf50d9e9c86f04694021444d">match_system</a> (<a class="el" href="#a4bfa8a9b32b9b52abbdde7c458290fb9">endianness</a> e)</td></tr>
<tr class="separator:a1d330a76cf50d9e9c86f04694021444d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d982129c25b66213d1c50e8b6a566c2" id="r_a2d982129c25b66213d1c50e8b6a566c2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d982129c25b66213d1c50e8b6a566c2">to_string</a> (<a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59">encoding_type</a> bom)</td></tr>
<tr class="separator:a2d982129c25b66213d1c50e8b6a566c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36862583b2f6130063292bcea21017d" id="r_af36862583b2f6130063292bcea21017d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a7a2290defcac825573ce84885fd832d2">simdutf_really_inline</a> <a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59">simdutf::encoding_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af36862583b2f6130063292bcea21017d">autodetect_encoding</a> (const uint8_t *input, size_t length) noexcept</td></tr>
<tr class="separator:af36862583b2f6130063292bcea21017d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fa290aa6d19541e1cf10407428e1fd" id="r_a44fa290aa6d19541e1cf10407428e1fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a7a2290defcac825573ce84885fd832d2">simdutf_really_inline</a> <a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44fa290aa6d19541e1cf10407428e1fd">detect_encodings</a> (const uint8_t *input, size_t length) noexcept</td></tr>
<tr class="separator:a44fa290aa6d19541e1cf10407428e1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ab06176309cea9c49e8342f657e502" id="r_a77ab06176309cea9c49e8342f657e502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77ab06176309cea9c49e8342f657e502">convert_utf32_to_latin1_with_errors</a> (const char32_t *input, size_t length, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:a77ab06176309cea9c49e8342f657e502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33387603a4aaf6088452a38a3d0f266" id="r_ac33387603a4aaf6088452a38a3d0f266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac33387603a4aaf6088452a38a3d0f266">convert_valid_utf32_to_latin1</a> (const char32_t *input, size_t length, char *latin1_buffer) noexcept</td></tr>
<tr class="separator:ac33387603a4aaf6088452a38a3d0f266"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7d7a78ed9afc42fba5adfc42e200c3de" name="a7d7a78ed9afc42fba5adfc42e200c3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7a78ed9afc42fba5adfc42e200c3de">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7d7a78ed9afc42fba5adfc42e200c3dea0f1ce753edf47d790870b3e710520f02" name="a7d7a78ed9afc42fba5adfc42e200c3dea0f1ce753edf47d790870b3e710520f02"></a>SIMDUTF_VERSION_MAJOR&#160;</td><td class="fielddoc"><p>The major version (MAJOR.minor.revision) of simdutf being used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d7a78ed9afc42fba5adfc42e200c3deabeaedb9d209c037a199b6a9039c79b46" name="a7d7a78ed9afc42fba5adfc42e200c3deabeaedb9d209c037a199b6a9039c79b46"></a>SIMDUTF_VERSION_MINOR&#160;</td><td class="fielddoc"><p>The minor version (major.MINOR.revision) of simdutf being used. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7d7a78ed9afc42fba5adfc42e200c3deadff56e8290b4b8fc340a95ecbededae2" name="a7d7a78ed9afc42fba5adfc42e200c3deadff56e8290b4b8fc340a95ecbededae2"></a>SIMDUTF_VERSION_REVISION&#160;</td><td class="fielddoc"><p>The revision (major.minor.REVISION) of simdutf being used. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6bd0ecc4f9b16b205f779497eef6bd59" name="a6bd0ecc4f9b16b205f779497eef6bd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd0ecc4f9b16b205f779497eef6bd59">&#9670;&#160;</a></span>encoding_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59">simdutf::encoding_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6bd0ecc4f9b16b205f779497eef6bd59a917dc582783b964eaac058d213dffd26" name="a6bd0ecc4f9b16b205f779497eef6bd59a917dc582783b964eaac058d213dffd26"></a>UTF8&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6bd0ecc4f9b16b205f779497eef6bd59a6ae826657cdafba0b4efc38fd73c8d7e" name="a6bd0ecc4f9b16b205f779497eef6bd59a6ae826657cdafba0b4efc38fd73c8d7e"></a>UTF16_LE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6bd0ecc4f9b16b205f779497eef6bd59a690fe2b3b619d0d5d75b25db6ed6ab30" name="a6bd0ecc4f9b16b205f779497eef6bd59a690fe2b3b619d0d5d75b25db6ed6ab30"></a>UTF16_BE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6bd0ecc4f9b16b205f779497eef6bd59a3ad7dfaaa28f2f00dbabca345fcd6147" name="a6bd0ecc4f9b16b205f779497eef6bd59a3ad7dfaaa28f2f00dbabca345fcd6147"></a>UTF32_LE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6bd0ecc4f9b16b205f779497eef6bd59a1311591f943599c3aa8c42797f3b3471" name="a6bd0ecc4f9b16b205f779497eef6bd59a1311591f943599c3aa8c42797f3b3471"></a>UTF32_BE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6bd0ecc4f9b16b205f779497eef6bd59a053aab5ec8acf4476abaee782ebf21f9" name="a6bd0ecc4f9b16b205f779497eef6bd59a053aab5ec8acf4476abaee782ebf21f9"></a>Latin1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6bd0ecc4f9b16b205f779497eef6bd59a93bd32959bf7e245a48602fb04068373" name="a6bd0ecc4f9b16b205f779497eef6bd59a93bd32959bf7e245a48602fb04068373"></a>unspecified&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4bfa8a9b32b9b52abbdde7c458290fb9" name="a4bfa8a9b32b9b52abbdde7c458290fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfa8a9b32b9b52abbdde7c458290fb9">&#9670;&#160;</a></span>endianness</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a4bfa8a9b32b9b52abbdde7c458290fb9">simdutf::endianness</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4bfa8a9b32b9b52abbdde7c458290fb9a5ac03fc4a9023316a738bb8d41b20390" name="a4bfa8a9b32b9b52abbdde7c458290fb9a5ac03fc4a9023316a738bb8d41b20390"></a>LITTLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4bfa8a9b32b9b52abbdde7c458290fb9ab3e432f36f75731ead119b4b32a5082d" name="a4bfa8a9b32b9b52abbdde7c458290fb9ab3e432f36f75731ead119b4b32a5082d"></a>BIG&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a21bb9bd60cb20c3c7912cd6731819f9e" name="a21bb9bd60cb20c3c7912cd6731819f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bb9bd60cb20c3c7912cd6731819f9e">&#9670;&#160;</a></span>error_code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a21bb9bd60cb20c3c7912cd6731819f9e">simdutf::error_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a21bb9bd60cb20c3c7912cd6731819f9eaefb7e6a3372b5b35515184a9ae6ff555" name="a21bb9bd60cb20c3c7912cd6731819f9eaefb7e6a3372b5b35515184a9ae6ff555"></a>SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a21bb9bd60cb20c3c7912cd6731819f9ea700595b55a7f9863f3efee4cb8d81fc0" name="a21bb9bd60cb20c3c7912cd6731819f9ea700595b55a7f9863f3efee4cb8d81fc0"></a>HEADER_BITS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a21bb9bd60cb20c3c7912cd6731819f9ea0c333e47a4a04d36b6360c53b34eab95" name="a21bb9bd60cb20c3c7912cd6731819f9ea0c333e47a4a04d36b6360c53b34eab95"></a>TOO_SHORT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a21bb9bd60cb20c3c7912cd6731819f9ea962d7aef8a0a173ad59a70ffe2d4b58c" name="a21bb9bd60cb20c3c7912cd6731819f9ea962d7aef8a0a173ad59a70ffe2d4b58c"></a>TOO_LONG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a21bb9bd60cb20c3c7912cd6731819f9ea25ff959549dda532a96298ccc63425d6" name="a21bb9bd60cb20c3c7912cd6731819f9ea25ff959549dda532a96298ccc63425d6"></a>OVERLONG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a21bb9bd60cb20c3c7912cd6731819f9ea2b72249220a281461ace00f6d4c0852d" name="a21bb9bd60cb20c3c7912cd6731819f9ea2b72249220a281461ace00f6d4c0852d"></a>TOO_LARGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a21bb9bd60cb20c3c7912cd6731819f9eaf3ab787bae3a3cb50a7b6b839dd10344" name="a21bb9bd60cb20c3c7912cd6731819f9eaf3ab787bae3a3cb50a7b6b839dd10344"></a>SURROGATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a21bb9bd60cb20c3c7912cd6731819f9ea9954c243b4cc61391de250c437123e09" name="a21bb9bd60cb20c3c7912cd6731819f9ea9954c243b4cc61391de250c437123e09"></a>OTHER&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a92f6a8aee83ae995b7f3c88f7355d374" name="a92f6a8aee83ae995b7f3c88f7355d374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f6a8aee83ae995b7f3c88f7355d374">&#9670;&#160;</a></span>autodetect_encoding() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59">simdutf::encoding_type</a> simdutf::autodetect_encoding </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Autodetect the encoding of the input, a single encoding is recommended. E.g., the function might return <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a917dc582783b964eaac058d213dffd26">simdutf::encoding_type::UTF8</a>, <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a6ae826657cdafba0b4efc38fd73c8d7e">simdutf::encoding_type::UTF16_LE</a>, <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a690fe2b3b619d0d5d75b25db6ed6ab30">simdutf::encoding_type::UTF16_BE</a>, or <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a3ad7dfaaa28f2f00dbabca345fcd6147">simdutf::encoding_type::UTF32_LE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the string to analyze. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the detected encoding type </dd></dl>

</div>
</div>
<a id="af36862583b2f6130063292bcea21017d" name="af36862583b2f6130063292bcea21017d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36862583b2f6130063292bcea21017d">&#9670;&#160;</a></span>autodetect_encoding() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a7a2290defcac825573ce84885fd832d2">simdutf_really_inline</a> <a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59">simdutf::encoding_type</a> simdutf::autodetect_encoding </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f85c5068e0dbfefce408c3bf8db0219" name="a3f85c5068e0dbfefce408c3bf8db0219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f85c5068e0dbfefce408c3bf8db0219">&#9670;&#160;</a></span>builtin_implementation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsimdutf_1_1implementation.html">implementation</a> * simdutf::builtin_implementation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a469ead7666feebbe482f2af34aeb9746" name="a469ead7666feebbe482f2af34aeb9746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469ead7666feebbe482f2af34aeb9746">&#9670;&#160;</a></span>change_endianness_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void simdutf::change_endianness_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the endianness of the input. Can be used to go from UTF-16LE to UTF-16BE or from UTF-16BE to UTF-16LE.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97c600c7480839057f59d37cd8d2dabd" name="a97c600c7480839057f59d37cd8d2dabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c600c7480839057f59d37cd8d2dabd">&#9670;&#160;</a></span>convert_latin1_to_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_latin1_to_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert a Latin1 string into a UTF-16 string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t. </dd></dl>

</div>
</div>
<a id="aea36e1bfc7301e764986e8774a613c96" name="aea36e1bfc7301e764986e8774a613c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea36e1bfc7301e764986e8774a613c96">&#9670;&#160;</a></span>convert_latin1_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_latin1_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert Latin1 string into UTF-16BE string.</p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a7942e1b1791ddba4afd565d85af7dc28" name="a7942e1b1791ddba4afd565d85af7dc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7942e1b1791ddba4afd565d85af7dc28">&#9670;&#160;</a></span>convert_latin1_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_latin1_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly Latin1 string into UTF-16LE string.</p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="ab6de840d05d27b1e8f0649e52108e56a" name="ab6de840d05d27b1e8f0649e52108e56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6de840d05d27b1e8f0649e52108e56a">&#9670;&#160;</a></span>convert_latin1_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_latin1_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert Latin1 string into UTF-32 string.</p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a9107a119fd2a80906c63fdb2eee511ad" name="a9107a119fd2a80906c63fdb2eee511ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9107a119fd2a80906c63fdb2eee511ad">&#9670;&#160;</a></span>convert_latin1_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_latin1_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert Latin1 string into UTF8 string.</p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="aa3c4d3f0103d876f3886b9b63818652d" name="aa3c4d3f0103d876f3886b9b63818652d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c4d3f0103d876f3886b9b63818652d">&#9670;&#160;</a></span>convert_utf16_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf16_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-16 string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="aa95a683210b1de91f7f99691d0f3c6e1" name="aa95a683210b1de91f7f99691d0f3c6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95a683210b1de91f7f99691d0f3c6e1">&#9670;&#160;</a></span>convert_utf16_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf16_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-16 string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources. This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a36e8440ad72605456605de79305ca765" name="a36e8440ad72605456605de79305ca765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e8440ad72605456605de79305ca765">&#9670;&#160;</a></span>convert_utf16_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf16_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-16 string into UTF-32 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a2e9ab41612aef151f0045aa51ff3dc63" name="a2e9ab41612aef151f0045aa51ff3dc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9ab41612aef151f0045aa51ff3dc63">&#9670;&#160;</a></span>convert_utf16_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf16_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-16 string into UTF-32 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="a41f44eb6f8785e97e88d0677a847a430" name="a41f44eb6f8785e97e88d0677a847a430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f44eb6f8785e97e88d0677a847a430">&#9670;&#160;</a></span>convert_utf16_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf16_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-16 string into UTF-8 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a6439cd96f125a50315bb102f4d23b396" name="a6439cd96f125a50315bb102f4d23b396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6439cd96f125a50315bb102f4d23b396">&#9670;&#160;</a></span>convert_utf16_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf16_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-16 string into UTF-8 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="affbef7b3a8b34073ec4a6f6731a3c318" name="affbef7b3a8b34073ec4a6f6731a3c318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbef7b3a8b34073ec4a6f6731a3c318">&#9670;&#160;</a></span>convert_utf16be_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf16be_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a1c25651c43a882706489f17a39b56ce0" name="a1c25651c43a882706489f17a39b56ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c25651c43a882706489f17a39b56ce0">&#9670;&#160;</a></span>convert_utf16be_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf16be_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources. This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a172ce7d5cb1903ec81b79c22c7de9c17" name="a172ce7d5cb1903ec81b79c22c7de9c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172ce7d5cb1903ec81b79c22c7de9c17">&#9670;&#160;</a></span>convert_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into UTF-32 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a72abf02976bc1f51bf174d219f012b9a" name="a72abf02976bc1f51bf174d219f012b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72abf02976bc1f51bf174d219f012b9a">&#9670;&#160;</a></span>convert_utf16be_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf16be_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into UTF-32 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="aebf67034f0962cf04679d45df70e56c6" name="aebf67034f0962cf04679d45df70e56c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf67034f0962cf04679d45df70e56c6">&#9670;&#160;</a></span>convert_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into UTF-8 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a611286f1d853f87d1dd9fe19c01297bb" name="a611286f1d853f87d1dd9fe19c01297bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611286f1d853f87d1dd9fe19c01297bb">&#9670;&#160;</a></span>convert_utf16be_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf16be_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a2649740b525188c2521002110052b43f" name="a2649740b525188c2521002110052b43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2649740b525188c2521002110052b43f">&#9670;&#160;</a></span>convert_utf16le_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf16le_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="abfa1cf3e743fb34b0cc3a9e46f3529ae" name="abfa1cf3e743fb34b0cc3a9e46f3529ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa1cf3e743fb34b0cc3a9e46f3529ae">&#9670;&#160;</a></span>convert_utf16le_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf16le_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources. This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a2d9e0688d52a327cf1c5b284289130c4" name="a2d9e0688d52a327cf1c5b284289130c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9e0688d52a327cf1c5b284289130c4">&#9670;&#160;</a></span>convert_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into UTF-32 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a3b08160058656bb26c0f7d5400017800" name="a3b08160058656bb26c0f7d5400017800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b08160058656bb26c0f7d5400017800">&#9670;&#160;</a></span>convert_utf16le_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf16le_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into UTF-32 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="a714aed8f48adc99a60baf00576f60a2c" name="a714aed8f48adc99a60baf00576f60a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714aed8f48adc99a60baf00576f60a2c">&#9670;&#160;</a></span>convert_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into UTF-8 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a0277ce4834fc226877ff3b5eb9cbfce6" name="a0277ce4834fc226877ff3b5eb9cbfce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0277ce4834fc226877ff3b5eb9cbfce6">&#9670;&#160;</a></span>convert_utf16le_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf16le_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="acd03e0dec5d12445d0c1335e257c7d4e" name="acd03e0dec5d12445d0c1335e257c7d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd03e0dec5d12445d0c1335e257c7d4e">&#9670;&#160;</a></span>convert_utf32_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf32_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into Latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="a77ab06176309cea9c49e8342f657e502" name="a77ab06176309cea9c49e8342f657e502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ab06176309cea9c49e8342f657e502">&#9670;&#160;</a></span>convert_utf32_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf32_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into Latin1 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="aae149859f89d6d04f0bac00ff0a6c225" name="aae149859f89d6d04f0bac00ff0a6c225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae149859f89d6d04f0bac00ff0a6c225">&#9670;&#160;</a></span>convert_utf32_to_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf32_to_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-32 string into a UTF-16 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="ae06ec3690a8fb376d3f89a0f6c43996a" name="ae06ec3690a8fb376d3f89a0f6c43996a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06ec3690a8fb376d3f89a0f6c43996a">&#9670;&#160;</a></span>convert_utf32_to_utf16_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf32_to_utf16_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-32 string into UTF-16 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="ae537271d61cefaf0d66b77d6e2dcc204" name="ae537271d61cefaf0d66b77d6e2dcc204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae537271d61cefaf0d66b77d6e2dcc204">&#9670;&#160;</a></span>convert_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-16BE string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="a9968fe1877bd08c259d5472ee9387c85" name="a9968fe1877bd08c259d5472ee9387c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9968fe1877bd08c259d5472ee9387c85">&#9670;&#160;</a></span>convert_utf32_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf32_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-16BE string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="a7d60b7a75ee9c22ce6d6165cc8892a27" name="a7d60b7a75ee9c22ce6d6165cc8892a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d60b7a75ee9c22ce6d6165cc8892a27">&#9670;&#160;</a></span>convert_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-16LE string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="a5a004fec5c7dac33e26f2485aec6ae4a" name="a5a004fec5c7dac33e26f2485aec6ae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a004fec5c7dac33e26f2485aec6ae4a">&#9670;&#160;</a></span>convert_utf32_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf32_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-16LE string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="a4a5102bcd1b8341b770c46a317c523fc" name="a4a5102bcd1b8341b770c46a317c523fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5102bcd1b8341b770c46a317c523fc">&#9670;&#160;</a></span>convert_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-8 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="a89b082c3f3a7b837121530b95bdf802b" name="a89b082c3f3a7b837121530b95bdf802b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b082c3f3a7b837121530b95bdf802b">&#9670;&#160;</a></span>convert_utf32_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf32_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-32 string into UTF-8 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="afc7a8e316f2f94801142d44b38d10b1b" name="afc7a8e316f2f94801142d44b38d10b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7a8e316f2f94801142d44b38d10b1b">&#9670;&#160;</a></span>convert_utf8_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf8_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into latin1 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="afcec8602ed1ee544f4d914f37b99862a" name="afcec8602ed1ee544f4d914f37b99862a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcec8602ed1ee544f4d914f37b99862a">&#9670;&#160;</a></span>convert_utf8_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf8_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into latin1 string with errors.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="af0932d08526cecb7bdc7e5a3411ec5bf" name="af0932d08526cecb7bdc7e5a3411ec5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0932d08526cecb7bdc7e5a3411ec5bf">&#9670;&#160;</a></span>convert_utf8_to_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf8_to_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-8 string into a UTF-16 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a830e4736fb947da8630fd5789de02821" name="a830e4736fb947da8630fd5789de02821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830e4736fb947da8630fd5789de02821">&#9670;&#160;</a></span>convert_utf8_to_utf16_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf8_to_utf16_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert possibly broken UTF-8 string into UTF-16 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="ad6451d4e382ae7b363cc9e2f024483bc" name="ad6451d4e382ae7b363cc9e2f024483bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6451d4e382ae7b363cc9e2f024483bc">&#9670;&#160;</a></span>convert_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-16BE string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a856950cac4f430a8421b2ede923637fd" name="a856950cac4f430a8421b2ede923637fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856950cac4f430a8421b2ede923637fd">&#9670;&#160;</a></span>convert_utf8_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf8_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="a2b4b9db9d1c9f4093fb3564b5991f51a" name="a2b4b9db9d1c9f4093fb3564b5991f51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4b9db9d1c9f4093fb3564b5991f51a">&#9670;&#160;</a></span>convert_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-16LE string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a51bee7068da946ea620e75f73496a539" name="a51bee7068da946ea620e75f73496a539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bee7068da946ea620e75f73496a539">&#9670;&#160;</a></span>convert_utf8_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf8_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="a181598fd56783ba70fe28d5096293e2e" name="a181598fd56783ba70fe28d5096293e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181598fd56783ba70fe28d5096293e2e">&#9670;&#160;</a></span>convert_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-32 string.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="aaf474179741fecc4c67047c39989bb99" name="aaf474179741fecc4c67047c39989bb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf474179741fecc4c67047c39989bb99">&#9670;&#160;</a></span>convert_utf8_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::convert_utf8_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert possibly broken UTF-8 string into UTF-32 string and stop on error.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="a03c7059e0e2e517932297e34a2c9808d" name="a03c7059e0e2e517932297e34a2c9808d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c7059e0e2e517932297e34a2c9808d">&#9670;&#160;</a></span>convert_valid_utf16_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf16_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert UTF-16 string into Latin1 string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a25ce5bd7f4e3f5052a9b0ae7b84761bc" name="a25ce5bd7f4e3f5052a9b0ae7b84761bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ce5bd7f4e3f5052a9b0ae7b84761bc">&#9670;&#160;</a></span>convert_valid_utf16_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf16_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert valid UTF-16 string into UTF-32 string.</p>
<p>This function assumes that the input string is valid UTF-16 (native endianness).</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a52addf246254b2f622ba0e08ea0cbf9c" name="a52addf246254b2f622ba0e08ea0cbf9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52addf246254b2f622ba0e08ea0cbf9c">&#9670;&#160;</a></span>convert_valid_utf16_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf16_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert valid UTF-16 string into UTF-8 string.</p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a1240906d0aec98a1546af9354f9ab238" name="a1240906d0aec98a1546af9354f9ab238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1240906d0aec98a1546af9354f9ab238">&#9670;&#160;</a></span>convert_valid_utf16be_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf16be_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16BE string into Latin1 string.</p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="ab3d3332f7c42911ff572fcb0e8458713" name="ab3d3332f7c42911ff572fcb0e8458713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d3332f7c42911ff572fcb0e8458713">&#9670;&#160;</a></span>convert_valid_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16BE string into UTF-32 string.</p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a95134fa021602c8cdab4df88548c0aef" name="a95134fa021602c8cdab4df88548c0aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95134fa021602c8cdab4df88548c0aef">&#9670;&#160;</a></span>convert_valid_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16BE string into UTF-8 string.</p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a26d78799c134df9ac4cdcd7dfbc66608" name="a26d78799c134df9ac4cdcd7dfbc66608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d78799c134df9ac4cdcd7dfbc66608">&#9670;&#160;</a></span>convert_valid_utf16le_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf16le_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16LE string into Latin1 string.</p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a410a780f6b16e03f8c185051db267d7d" name="a410a780f6b16e03f8c185051db267d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410a780f6b16e03f8c185051db267d7d">&#9670;&#160;</a></span>convert_valid_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16LE string into UTF-32 string.</p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="ae0e4da792a442f65b10eb5bb4afcf2b8" name="ae0e4da792a442f65b10eb5bb4afcf2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e4da792a442f65b10eb5bb4afcf2b8">&#9670;&#160;</a></span>convert_valid_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-16LE string into UTF-8 string.</p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="ac33387603a4aaf6088452a38a3d0f266" name="ac33387603a4aaf6088452a38a3d0f266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33387603a4aaf6088452a38a3d0f266">&#9670;&#160;</a></span>convert_valid_utf32_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf32_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-32 string into Latin1 string.</p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a8e331550c267fcab10956c419faab971" name="a8e331550c267fcab10956c419faab971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e331550c267fcab10956c419faab971">&#9670;&#160;</a></span>convert_valid_utf32_to_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf32_to_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert valid UTF-32 string into a UTF-16 string.</p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="ab12a863ee69a69bdcc5282e3c61e2e52" name="ab12a863ee69a69bdcc5282e3c61e2e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12a863ee69a69bdcc5282e3c61e2e52">&#9670;&#160;</a></span>convert_valid_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-32 string into UTF-16BE string.</p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a306ba01a7f899889203476834636c7b0" name="a306ba01a7f899889203476834636c7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306ba01a7f899889203476834636c7b0">&#9670;&#160;</a></span>convert_valid_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-32 string into UTF-16LE string.</p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a0e2a8c972f8876b2e96fa32b839feacc" name="a0e2a8c972f8876b2e96fa32b839feacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2a8c972f8876b2e96fa32b839feacc">&#9670;&#160;</a></span>convert_valid_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>utf8_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-32 string into UTF-8 string.</p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="ad7eff6ac225f4d972f941943e54f72e7" name="ad7eff6ac225f4d972f941943e54f72e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7eff6ac225f4d972f941943e54f72e7">&#9670;&#160;</a></span>convert_valid_utf8_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf8_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>latin1_output</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-8 string into latin1 string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a7b12aa933318264f753a376008491a8e" name="a7b12aa933318264f753a376008491a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b12aa933318264f753a376008491a8e">&#9670;&#160;</a></span>convert_valid_utf8_to_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf8_to_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness, convert valid UTF-8 string into a UTF-16 string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

</div>
</div>
<a id="a724023c3f0ea36e4a18e06e13b575301" name="a724023c3f0ea36e4a18e06e13b575301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724023c3f0ea36e4a18e06e13b575301">&#9670;&#160;</a></span>convert_valid_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-8 string into UTF-16BE string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

</div>
</div>
<a id="ad4214bac8238956d9778766bfb3f486f" name="ad4214bac8238956d9778766bfb3f486f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4214bac8238956d9778766bfb3f486f">&#9670;&#160;</a></span>convert_valid_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *</td>          <td class="paramname"><span class="paramname"><em>utf16_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-8 string into UTF-16LE string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

</div>
</div>
<a id="a373f28290220b972c49f53a7daf9243f" name="a373f28290220b972c49f53a7daf9243f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373f28290220b972c49f53a7daf9243f">&#9670;&#160;</a></span>convert_valid_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::convert_valid_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *</td>          <td class="paramname"><span class="paramname"><em>utf32_buffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert valid UTF-8 string into UTF-32 string.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t </dd></dl>

</div>
</div>
<a id="a7b56c9dfde1822d8b5f78105cee25e36" name="a7b56c9dfde1822d8b5f78105cee25e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b56c9dfde1822d8b5f78105cee25e36">&#9670;&#160;</a></span>count_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::count_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of code points (characters) in the string assuming that it is valid.</p>
<p>This function assumes that the input string is valid UTF-16 (native endianness).</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a58d0d4bc6e61b53d17bf944d2037c7f9" name="a58d0d4bc6e61b53d17bf944d2037c7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d0d4bc6e61b53d17bf944d2037c7f9">&#9670;&#160;</a></span>count_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::count_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of code points (characters) in the string assuming that it is valid.</p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="aab94b40d9fecb4a04f1d0500f561da72" name="aab94b40d9fecb4a04f1d0500f561da72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab94b40d9fecb4a04f1d0500f561da72">&#9670;&#160;</a></span>count_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::count_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of code points (characters) in the string assuming that it is valid.</p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a68327d86eea5cd68c673e699fd9fbedd" name="a68327d86eea5cd68c673e699fd9fbedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68327d86eea5cd68c673e699fd9fbedd">&#9670;&#160;</a></span>count_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::count_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of code points (characters) in the string assuming that it is valid.</p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="abc5b2cd0b1d28ce104f92dbd39adeea8" name="abc5b2cd0b1d28ce104f92dbd39adeea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5b2cd0b1d28ce104f92dbd39adeea8">&#9670;&#160;</a></span>detect_encodings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> int simdutf::detect_encodings </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Autodetect the possible encodings of the input in one pass. E.g., if the input might be UTF-16LE or UTF-8, this function returns the value (<a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a917dc582783b964eaac058d213dffd26">simdutf::encoding_type::UTF8</a> | <a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59a6ae826657cdafba0b4efc38fd73c8d7e">simdutf::encoding_type::UTF16_LE</a>).</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the string to analyze. </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the detected encoding type </dd></dl>

</div>
</div>
<a id="a44fa290aa6d19541e1cf10407428e1fd" name="a44fa290aa6d19541e1cf10407428e1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fa290aa6d19541e1cf10407428e1fd">&#9670;&#160;</a></span>detect_encodings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a7a2290defcac825573ce84885fd832d2">simdutf_really_inline</a> <a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> int simdutf::detect_encodings </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26f77c56a51f2c53ddaf5d29d7995483" name="a26f77c56a51f2c53ddaf5d29d7995483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f77c56a51f2c53ddaf5d29d7995483">&#9670;&#160;</a></span>get_active_implementation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a5e25f8d632d07af7b61d9174d2461ba4">SIMDUTF_DLLIMPORTEXPORT</a> <a class="el" href="classsimdutf_1_1internal_1_1atomic__ptr.html">internal::atomic_ptr</a>&lt; const <a class="el" href="classsimdutf_1_1implementation.html">implementation</a> &gt; &amp; simdutf::get_active_implementation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The active implementation.</p>
<p>The active implementation.</p>
<p>Automatically initialized on first use to the most advanced implementation supported by this hardware. </p>

</div>
</div>
<a id="a447e9efa7338521159ba175edab76759" name="a447e9efa7338521159ba175edab76759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447e9efa7338521159ba175edab76759">&#9670;&#160;</a></span>get_available_implementations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a5e25f8d632d07af7b61d9174d2461ba4">SIMDUTF_DLLIMPORTEXPORT</a> const <a class="el" href="classsimdutf_1_1internal_1_1available__implementation__list.html">internal::available_implementation_list</a> &amp; simdutf::get_available_implementations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The list of available implementations compiled into simdutf. </p>

</div>
</div>
<a id="a4766b9aa6062439b3187c26a58c4efbb" name="a4766b9aa6062439b3187c26a58c4efbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4766b9aa6062439b3187c26a58c4efbb">&#9670;&#160;</a></span>latin1_length_from_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::latin1_length_from_utf16 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9643b9547c15a476fcd31b16da4483b" name="ae9643b9547c15a476fcd31b16da4483b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9643b9547c15a476fcd31b16da4483b">&#9670;&#160;</a></span>latin1_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::latin1_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c1a84e9f930c74d0911bdf540e72d45" name="a4c1a84e9f930c74d0911bdf540e72d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1a84e9f930c74d0911bdf540e72d45">&#9670;&#160;</a></span>latin1_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::latin1_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-8 string would require in Latin1 format.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-8 string as Latin1 </dd></dl>

</div>
</div>
<a id="a1d330a76cf50d9e9c86f04694021444d" name="a1d330a76cf50d9e9c86f04694021444d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d330a76cf50d9e9c86f04694021444d">&#9670;&#160;</a></span>match_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool simdutf::match_system </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a4bfa8a9b32b9b52abbdde7c458290fb9">endianness</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d982129c25b66213d1c50e8b6a566c2" name="a2d982129c25b66213d1c50e8b6a566c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d982129c25b66213d1c50e8b6a566c2">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string simdutf::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6bd0ecc4f9b16b205f779497eef6bd59">encoding_type</a></td>          <td class="paramname"><span class="paramname"><em>bom</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a776121f0f161fb2be1f7b6bc1dbbfb7b" name="a776121f0f161fb2be1f7b6bc1dbbfb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776121f0f161fb2be1f7b6bc1dbbfb7b">&#9670;&#160;</a></span>trim_partial_utf16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::trim_partial_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a valid UTF-16 string having a possibly truncated last character, this function checks the end of string. If the last character is truncated (or partial), then it returns a shorter length (shorter by 1 unit) so that the short UTF-16 strings only contain complete characters. If there is no truncated character, the original length is returned.</p>
<p>This function assumes that the input string is valid UTF-16, but possibly truncated. We use the native endianness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string in unit, possibly shorter by 1 unit </dd></dl>

</div>
</div>
<a id="acf62a80eb3692e0cbd1c5f241a0976ac" name="acf62a80eb3692e0cbd1c5f241a0976ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf62a80eb3692e0cbd1c5f241a0976ac">&#9670;&#160;</a></span>trim_partial_utf16be()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::trim_partial_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a valid UTF-16BE string having a possibly truncated last character, this function checks the end of string. If the last character is truncated (or partial), then it returns a shorter length (shorter by 1 unit) so that the short UTF-16BE strings only contain complete characters. If there is no truncated character, the original length is returned.</p>
<p>This function assumes that the input string is valid UTF-16BE, but possibly truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string in bytes, possibly shorter by 1 unit </dd></dl>

</div>
</div>
<a id="aa9de79653f90a49a608f46c2c9932078" name="aa9de79653f90a49a608f46c2c9932078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9de79653f90a49a608f46c2c9932078">&#9670;&#160;</a></span>trim_partial_utf16le()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::trim_partial_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a valid UTF-16LE string having a possibly truncated last character, this function checks the end of string. If the last character is truncated (or partial), then it returns a shorter length (shorter by 1 unit) so that the short UTF-16LE strings only contain complete characters. If there is no truncated character, the original length is returned.</p>
<p>This function assumes that the input string is valid UTF-16LE, but possibly truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string in unit, possibly shorter by 1 unit </dd></dl>

</div>
</div>
<a id="aee93cbcf7cf2f323d85233a4be0ad690" name="aee93cbcf7cf2f323d85233a4be0ad690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee93cbcf7cf2f323d85233a4be0ad690">&#9670;&#160;</a></span>trim_partial_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::trim_partial_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a valid UTF-8 string having a possibly truncated last character, this function checks the end of string. If the last character is truncated (or partial), then it returns a shorter length (shorter by 1 to 3 bytes) so that the short UTF-8 strings only contain complete characters. If there is no truncated character, the original length is returned.</p>
<p>This function assumes that the input string is valid UTF-8, but possibly truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string in bytes, possibly shorter by 1 to 3 bytes </dd></dl>

</div>
</div>
<a id="a01d25502dcadef33d82564bdb7c16357" name="a01d25502dcadef33d82564bdb7c16357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d25502dcadef33d82564bdb7c16357">&#9670;&#160;</a></span>utf16_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf16_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe94e2686b242e2b818e8f33a8f3a9cb" name="afe94e2686b242e2b818e8f33a8f3a9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe94e2686b242e2b818e8f33a8f3a9cb">&#9670;&#160;</a></span>utf16_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf16_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of two-byte code units that this UTF-32 string would require in UTF-16 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-16 </dd></dl>

</div>
</div>
<a id="a997011ac59fd9c3667280d566599c2cb" name="a997011ac59fd9c3667280d566599c2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997011ac59fd9c3667280d566599c2cb">&#9670;&#160;</a></span>utf16_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf16_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of 2-byte code units that this UTF-8 string would require in UTF-16LE format.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char16_t code units required to encode the UTF-8 string as UTF-16LE </dd></dl>

</div>
</div>
<a id="ae4457c6b706f3ef3cd37702582874640" name="ae4457c6b706f3ef3cd37702582874640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4457c6b706f3ef3cd37702582874640">&#9670;&#160;</a></span>utf32_length_from_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf32_length_from_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness; Compute the number of bytes that this UTF-16 string would require in UTF-32 format.</p>
<p>This function is equivalent to count_utf16.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as UTF-32 </dd></dl>

</div>
</div>
<a id="a984ec93559ce641520d984aa6eb22973" name="a984ec93559ce641520d984aa6eb22973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984ec93559ce641520d984aa6eb22973">&#9670;&#160;</a></span>utf32_length_from_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf32_length_from_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-16BE string would require in UTF-32 format.</p>
<p>This function is equivalent to count_utf16be.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16BE string as UTF-32 </dd></dl>

</div>
</div>
<a id="a194a30f90efb19fd5d4f5e04af490aec" name="a194a30f90efb19fd5d4f5e04af490aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194a30f90efb19fd5d4f5e04af490aec">&#9670;&#160;</a></span>utf32_length_from_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf32_length_from_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-16LE string would require in UTF-32 format.</p>
<p>This function is equivalent to count_utf16le.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as UTF-32 </dd></dl>

</div>
</div>
<a id="a905d22f0a789a77e69785956c49cf330" name="a905d22f0a789a77e69785956c49cf330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905d22f0a789a77e69785956c49cf330">&#9670;&#160;</a></span>utf32_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf32_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of 4-byte code units that this UTF-8 string would require in UTF-32 format.</p>
<p>This function is equivalent to count_utf8</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char32_t code units required to encode the UTF-8 string as UTF-32 </dd></dl>

</div>
</div>
<a id="aa8715a943ff432d71c26da384cf32839" name="aa8715a943ff432d71c26da384cf32839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8715a943ff432d71c26da384cf32839">&#9670;&#160;</a></span>utf8_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf8_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of bytes that this Latin1 string would require in UTF-8 format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the Latin1 string as UTF-8 </dd></dl>

</div>
</div>
<a id="af94bd238016344ff84fc64dd59c11db8" name="af94bd238016344ff84fc64dd59c11db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94bd238016344ff84fc64dd59c11db8">&#9670;&#160;</a></span>utf8_length_from_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf8_length_from_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness; Compute the number of bytes that this UTF-16 string would require in UTF-8 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as UTF-8 </dd></dl>

</div>
</div>
<a id="a7694416b37ad013dad68752afdfd7b44" name="a7694416b37ad013dad68752afdfd7b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7694416b37ad013dad68752afdfd7b44">&#9670;&#160;</a></span>utf8_length_from_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf8_length_from_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-16BE string would require in UTF-8 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16BE string as UTF-8 </dd></dl>

</div>
</div>
<a id="a60198c318e878c68771e2af4c60fb0ab" name="a60198c318e878c68771e2af4c60fb0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60198c318e878c68771e2af4c60fb0ab">&#9670;&#160;</a></span>utf8_length_from_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf8_length_from_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-16LE string would require in UTF-8 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as UTF-8 </dd></dl>

</div>
</div>
<a id="a10f3924e36387a861736ae870ebf8721" name="a10f3924e36387a861736ae870ebf8721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f3924e36387a861736ae870ebf8721">&#9670;&#160;</a></span>utf8_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> size_t simdutf::utf8_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of bytes that this UTF-32 string would require in UTF-8 format.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-8 </dd></dl>

</div>
</div>
<a id="af69c6eef367452f03ae298a6b4a4772d" name="af69c6eef367452f03ae298a6b4a4772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69c6eef367452f03ae298a6b4a4772d">&#9670;&#160;</a></span>validate_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::validate_ascii </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the ASCII string.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid ASCII. </dd></dl>

</div>
</div>
<a id="aee8517cb96f285347e5312f95b72fa6e" name="aee8517cb96f285347e5312f95b72fa6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8517cb96f285347e5312f95b72fa6e">&#9670;&#160;</a></span>validate_ascii_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::validate_ascii_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the ASCII string and stop on error. It might be faster than validate_utf8 when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a5d583d2142e4f818ca44b55cb7b492ef" name="a5d583d2142e4f818ca44b55cb7b492ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d583d2142e4f818ca44b55cb7b492ef">&#9670;&#160;</a></span>validate_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::validate_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness; Validate the UTF-16 string. This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf16_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16. </dd></dl>

</div>
</div>
<a id="aae9ef39df3b3c1e0d5c35e5be83e60b6" name="aae9ef39df3b3c1e0d5c35e5be83e60b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9ef39df3b3c1e0d5c35e5be83e60b6">&#9670;&#160;</a></span>validate_utf16_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::validate_utf16_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using native endianness; Validate the UTF-16 string and stop on error. It might be faster than validate_utf16 when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a03f46e6de89a8eea5a55a0054e0dfbc6" name="a03f46e6de89a8eea5a55a0054e0dfbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f46e6de89a8eea5a55a0054e0dfbc6">&#9670;&#160;</a></span>validate_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::validate_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-16BE string. This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf16be_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16BE. </dd></dl>

</div>
</div>
<a id="a40e8e0f72d343c0d140d4a73f24d74c4" name="a40e8e0f72d343c0d140d4a73f24d74c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e8e0f72d343c0d140d4a73f24d74c4">&#9670;&#160;</a></span>validate_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::validate_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-16BE string and stop on error. It might be faster than validate_utf16be when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a0edbc803d79993e0a1aa8a1dd9cb587f" name="a0edbc803d79993e0a1aa8a1dd9cb587f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edbc803d79993e0a1aa8a1dd9cb587f">&#9670;&#160;</a></span>validate_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::validate_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-16LE string. This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf16le_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16LE. </dd></dl>

</div>
</div>
<a id="ab0cb4b76c144be3877bccee498364125" name="ab0cb4b76c144be3877bccee498364125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cb4b76c144be3877bccee498364125">&#9670;&#160;</a></span>validate_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::validate_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-16LE string and stop on error. It might be faster than validate_utf16le when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a6a6f5318d1bbaa51e60d8975848f2a99" name="a6a6f5318d1bbaa51e60d8975848f2a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6f5318d1bbaa51e60d8975848f2a99">&#9670;&#160;</a></span>validate_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::validate_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-32 string. This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf32_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte code units (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-32. </dd></dl>

</div>
</div>
<a id="ad40f34e563a1c9989b876ff087eaacd8" name="ad40f34e563a1c9989b876ff087eaacd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40f34e563a1c9989b876ff087eaacd8">&#9670;&#160;</a></span>validate_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::validate_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-32 string and stop on error. It might be faster than validate_utf32 when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte code units (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a5d3088077c0230659012b58fd3b783c1" name="a5d3088077c0230659012b58fd3b783c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3088077c0230659012b58fd3b783c1">&#9670;&#160;</a></span>validate_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> bool simdutf::validate_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-8 string. This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf8_with_errors.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-8. </dd></dl>

</div>
</div>
<a id="a909de1285ace38031be40fce13465509" name="a909de1285ace38031be40fce13465509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909de1285ace38031be40fce13465509">&#9670;&#160;</a></span>validate_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="simdutf_8h.html#a8bf5cd9f63bfbc2bbc04e6aa71cc3cbb">simdutf_warn_unused</a> <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::validate_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate the UTF-8 string and stop on error.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesimdutf.html">simdutf</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
